---
title: "Programmatic Flow"
description: "Build custom authentication UIs with full control using discover and submit APIs"
---

Our Programmatic flow gives you complete control over the user experience to generate Agent. Instead of redirecting users to the hosted UI, you build your own UI and use the discover/submit APIs to drive the authentication.

Use the Programmatic flow when:
- You need a custom authentication UI that matches your app's design
- You're building automated/headless authentication scenarios
- You have credentials stored and want to authenticate without user interaction
- You need fine-grained control over the auth flow

## How It Works

<Steps>
  <Step title="Create Auth Agent and Invocation">
    Create an auth agent and start an invocation (same as [Hosted UI](/agent-auth/hosted-ui))
  </Step>
  <Step title="Exchange Handoff Code for JWT">
    Exchange the one-time handoff code for a scoped JWT token
  </Step>
  <Step title="Discover Login Fields">
    Call `discover()` to get the form fields on the login page
  </Step>
  <Step title="Submit Credentials">
    Call `submit()` with the field values to attempt login
  </Step>
  <Step title="Handle Multi-Step Auth">
    If additional fields are returned (2FA, OTP), collect and submit again
  </Step>
</Steps>

## Getting started

### 1. Create an Auth Agent

An Auth Agent represents a (domain, [profile](/browsers/profiles)) pair. Creating one is idempotent—if an agent already exists for the domain and profile, it returns the existing one.

```typescript
const agent = await kernel.agents.auth.create({
  target_domain: 'example.com',      // Required: domain to authenticate
  profile_name: 'my-profile',        // Required: profile to store session
  login_url: 'https://example.com/login', // Optional: speeds up discovery
});
```

### 2. Start an Invocation

An invocation starts a new authentication attempt. It returns a `handoff_code` to create a JWT.

```typescript
const invocation = await kernel.agents.auth.invocations.create({
  auth_agent_id: agent.id,
});
```

Optionally, enable automatic re-authentication when sessions expire. When credentials are saved, the Auth Agent automatically re-authenticates without user interaction (see [FAQ](/agent-auth/faq)). 

```typescript
const invocation = await kernel.agents.auth.invocations.create({
  auth_agent_id: agent.id,
  save_credential_as: 'my-saved-creds', // Save credentials for automatic re-auth
});
```

<Info>
If the response returns `logged_in` as `true`, the profile is already authenticated. Skip the redirect and go straight to using the profile.
</Info>

### 3. Exchange Handoff Code for JWT

The handoff code is a one-time credential that you exchange for a JWT token. This JWT is scoped to the specific invocation and grants permission to control the browser session.

```typescript
const exchange = await kernel.agents.auth.invocations.exchange(
  invocation.invocation_id,
  { code: invocation.handoff_code }
);

const jwt = exchange.jwt; // Valid for 30 minutes
```

<Warning>
The handoff code can only be used once and expires after 5 minutes. The JWT is valid for 30 minutes.
</Warning>

### 4. Create JWT-Authenticated Client

Create a new Kernel client using the JWT for subsequent API calls:

```typescript
const jwtKernel = new Kernel({ apiKey: exchange.jwt });
```

This client has limited permissions—it can only call the discover and submit endpoints for this specific invocation.

### 5. Discover Login Fields

Call `discover()` to navigate to the login page and extract form fields:

```typescript
const discoverResponse = await jwtKernel.agents.auth.invocations.discover(
  invocation.invocation_id,
  { login_url: 'https://example.com/login' } // Optional: override login URL
);
```

<Info>
If `discover()` returns `logged_in: true`, the profile is already authenticated from a previous session. No credentials are needed—proceed to using the profile.
</Info>

### 6. Map Credentials to Fields

The discover response returns an array of fields with `name`, `type`, and `label` properties. Use the `name` as the key when submitting credentials:

```typescript
// Discovered fields
const fields = [
  { name: 'email', type: 'email', label: 'Email Address' },
  { name: 'password', type: 'password', label: 'Password' }
];

// Your stored credentials
const credentials = {
  email: 'user@example.com',
  password: 'secretpassword'
};

// Map to field_values using field.name as key
const fieldValues = {
  'email': credentials.email,      // field.name → credential value
  'password': credentials.password
};
```

### 7. Submit Credentials

Submit the mapped field values to attempt login:

```typescript
const submitResponse = await jwtKernel.agents.auth.invocations.submit(
  invocation.invocation_id,
  { field_values: fieldValues }
);
```

### 8. Handle Multi-Step Auth

When `needs_additional_auth` is `true`, this means the webpage is showing new fields required for submission (typically 2FA/OTP). Collect the additional values and submit again:

```typescript
while (submitResponse.needs_additional_auth && submitResponse.additional_fields) {
  // Show the additional fields to the user
  console.log('Additional fields needed:', submitResponse.additional_fields);

  // Collect values (e.g., prompt user for 2FA code)
  const additionalValues: Record<string, string> = {};
  for (const field of submitResponse.additional_fields) {
    if (field.type === 'code' || field.name.includes('code')) {
      additionalValues[field.name] = await promptUserForOTP();
    }
  }

  // Submit again
  submitResponse = await jwtKernel.agents.auth.invocations.submit(
    invocation.invocation_id,
    { field_values: additionalValues }
  );
}
```

## Complete Example

<CodeGroup>
```typescript TypeScript
import Kernel from '@onkernel/sdk';

const kernel = new Kernel();

// Step 1: Create Auth Agent and Invocation
const agent = await kernel.agents.auth.create({
  target_domain: 'example.com',
  profile_name: 'my-profile',
});

const invocation = await kernel.agents.auth.invocations.create({
  auth_agent_id: agent.id,
});

if (invocation.status === 'ALREADY_AUTHENTICATED') {
  console.log('Already authenticated!');
  // Profile is ready to use
} else {
  // Step 2: Exchange handoff code for JWT
  const exchange = await kernel.agents.auth.invocations.exchange(
    invocation.invocation_id,
    { code: invocation.handoff_code }
  );

  // Step 3: Create JWT-authenticated client
  const jwtKernel = new Kernel({ apiKey: exchange.jwt });

  // Step 4: Discover login fields
  const discoverResponse = await jwtKernel.agents.auth.invocations.discover(
    invocation.invocation_id,
    {}
  );

  if (discoverResponse.logged_in) {
    console.log('Already logged in during discovery!');
  } else if (discoverResponse.success && discoverResponse.fields) {
    console.log('Discovered fields:', discoverResponse.fields);

    // Step 5: Map credentials to discovered fields
    const fieldValues = mapCredentialsToFields(discoverResponse.fields, {
      email: 'user@example.com',
      password: 'secretpassword',
    });

    // Step 6: Submit credentials
    let submitResponse = await jwtKernel.agents.auth.invocations.submit(
      invocation.invocation_id,
      { field_values: fieldValues }
    );

    // Step 7: Handle multi-step auth
    while (submitResponse.needs_additional_auth && submitResponse.additional_fields) {
      console.log('Additional auth required:', submitResponse.additional_fields);

      // Collect 2FA code from user
      const otpCode = await promptUserForOTP();

      const additionalValues = mapCredentialsToFields(
        submitResponse.additional_fields,
        { code: otpCode }
      );

      submitResponse = await jwtKernel.agents.auth.invocations.submit(
        invocation.invocation_id,
        { field_values: additionalValues }
      );
    }

    if (submitResponse.logged_in) {
      console.log('Authentication successful!');
    } else if (submitResponse.error_message) {
      console.error('Login failed:', submitResponse.error_message);
    }
  }
}

// Helper function to map credentials to discovered fields
function mapCredentialsToFields(
  fields: Array<{ name: string; type: string; label?: string }>,
  credentials: Record<string, string>
): Record<string, string> {
  const fieldValues: Record<string, string> = {};

  for (const field of fields) {
    const name = field.name.toLowerCase();
    const type = field.type.toLowerCase();
    const label = (field.label || '').toLowerCase();

    if (type === 'email' || name.includes('email') || label.includes('email')) {
      fieldValues[field.name] = credentials.email || '';
    } else if (type === 'password' || name.includes('password')) {
      fieldValues[field.name] = credentials.password || '';
    } else if (type === 'code' || name.includes('code') || name.includes('otp')) {
      fieldValues[field.name] = credentials.code || '';
    } else if (name.includes('username')) {
      fieldValues[field.name] = credentials.email || credentials.username || '';
    }
  }

  return fieldValues;
}
```

```python Python
from kernel import Kernel

kernel = Kernel()

# Step 1: Create Auth Agent and Invocation
agent = await kernel.agents.auth.create(
    target_domain="example.com",
    profile_name="my-profile",
)

invocation = await kernel.agents.auth.invocations.create(
    auth_agent_id=agent.id,
)

if invocation.status == "ALREADY_AUTHENTICATED":
    print("Already authenticated!")
else:
    # Step 2: Exchange handoff code for JWT
    exchange = await kernel.agents.auth.invocations.exchange(
        invocation.invocation_id,
        code=invocation.handoff_code,
    )

    # Step 3: Create JWT-authenticated client
    jwt_kernel = Kernel(api_key=exchange.jwt)

    # Step 4: Discover login fields
    discover_response = await jwt_kernel.agents.auth.invocations.discover(
        invocation.invocation_id,
    )

    if discover_response.logged_in:
        print("Already logged in during discovery!")
    elif discover_response.success and discover_response.fields:
        print(f"Discovered fields: {discover_response.fields}")

        # Step 5: Map credentials to discovered fields
        field_values = map_credentials_to_fields(
            discover_response.fields,
            {"email": "user@example.com", "password": "secretpassword"},
        )

        # Step 6: Submit credentials
        submit_response = await jwt_kernel.agents.auth.invocations.submit(
            invocation.invocation_id,
            field_values=field_values,
        )

        # Step 7: Handle multi-step auth
        while (
            submit_response.needs_additional_auth
            and submit_response.additional_fields
        ):
            print(f"Additional auth required: {submit_response.additional_fields}")
            otp_code = input("Enter 2FA code: ")

            additional_values = map_credentials_to_fields(
                submit_response.additional_fields,
                {"code": otp_code},
            )

            submit_response = await jwt_kernel.agents.auth.invocations.submit(
                invocation.invocation_id,
                field_values=additional_values,
            )

        if submit_response.logged_in:
            print("Authentication successful!")
        elif submit_response.error_message:
            print(f"Login failed: {submit_response.error_message}")


def map_credentials_to_fields(fields, credentials):
    field_values = {}
    for field in fields:
        name = field.name.lower()
        field_type = field.type.lower()
        label = (field.label or "").lower()

        if field_type == "email" or "email" in name or "email" in label:
            field_values[field.name] = credentials.get("email", "")
        elif field_type == "password" or "password" in name:
            field_values[field.name] = credentials.get("password", "")
        elif field_type == "code" or "code" in name or "otp" in name:
            field_values[field.name] = credentials.get("code", "")
        elif "username" in name:
            field_values[field.name] = credentials.get("email") or credentials.get("username", "")

    return field_values
```
</CodeGroup>

## Notes

- The JWT is scoped to the specific invocation and cannot access other resources
- Credentials submitted via `submit()` are sent directly to the target site
- Credentials are never logged, stored in plaintext, or passed to LLMs
- The browser session is isolated and destroyed after the invocation completes
