---
title: "Early Preview"
description: "Agent Auth early preview documentation for testers"
---

<Warning>
This is early preview documentation for Agent Auth testers. Features and APIs may change before general availability.
</Warning>

## What is Agent Auth?

Agent Auth is an AI-powered authentication system that helps you log users into any website and save their authenticated browser session (profile) for future automations. It uses web agents to intelligently discover login forms, dynamically generate credential inputs, and handle multi-step authentication flows like 2FA/OTP.

**Key features:**

- Automatically detects login form fields on any website
- Dynamically generates forms based on discovered fields
- Handles multi-step auth (2FA, OTP, magic links)
- Saves authenticated browser profiles for reuse
- Hourly session checks to detect when re-authentication is needed
- Credentials are encrypted and submitted programmatically—never stored in plaintext or shared with LLMs
- Store credentials for fully automated re-authentication
- `reauth()` endpoint for programmatic session refresh

## Choose Your Integration

| Flow | Who enters credentials? | Best for |
|------|------------------------|----------|
| **Hosted UI** | User, in Kernel's hosted page | Simplest integration, minimal code |
| **Custom UI** | User, in YOUR app's UI | Full control over login UX |
| **Programmatic** | No one (you provide them in code) | Automated/headless, bot accounts |

## How It Works

1. Your backend calls `kernel.agents.auth.create()` to setup the agent, then calls `kernel.agents.auth.invocations.create()` to start the flow → Returns `invocation_id`, `hosted_url`, `handoff_code`, and `expires_at`
2. User is redirected to `hosted_url` → Enters credentials when prompted → Handles 2FA/OTP if needed → Profile saved on success
3. Your backend polls invocation status → Uses saved profile in future browser automations
4. After authentication completes, Agent Auth automatically monitors the session every hour and updates the status if re-authentication is required
5. If credentials are stored, Agent Auth can automatically re-authenticate when sessions expire

<Tip>
**Plan for re-auth from the start.** If you want automated re-authentication later, use `save_credential_as` during the initial login. This saves credentials and form selectors, enabling `can_reauth` for future sessions.
</Tip>

## Key Concepts

### The Three Primitives

| Concept | What it is | Lifespan |
|---------|-----------|----------|
| **Profile** | A saved browser session (cookies, localStorage). Once authenticated, use it to get logged-in browsers. | Permanent |
| **Auth Agent** | Binds a profile to a domain. Tracks auth status, credentials, and selectors. | Permanent |
| **Invocation** | A single login attempt. Created each time you need to authenticate. | 5 minutes |

### Auth Agent

An Auth Agent is a persistent entity that manages authentication for a specific domain + profile combination. You create or retrieve Auth Agents using `kernel.agents.auth.create()`. This method is idempotent—if an agent already exists for the domain and profile, it returns the existing one.

The Auth Agent stores:

- The target domain (e.g., `doordash.com`)
- The linked browser profile
- The login URL (learned during discovery, used to speed up future invocations)
- The auth check URL (where to verify logged-in state)
- Current authentication status (`AUTHENTICATED` or `NEEDS_AUTH`)
- Linked credential ID for automated re-auth
- Saved form selectors for deterministic re-auth

**Auth Agent fields:**

| Field | Description |
|-------|-------------|
| `id` | Unique identifier for the agent |
| `status` | `AUTHENTICATED` or `NEEDS_AUTH` |
| `credential_id` | ID of linked credential (if any) |
| `credential_name` | Name of linked credential (if any) |
| `can_reauth` | `true` if agent has credentials AND selectors for automated re-auth |
| `has_selectors` | `true` if form selectors were saved from a previous login |
| `last_auth_check_at` | When the last session health check was performed |

<Note>
**When is `can_reauth` true?** The agent must have BOTH:
1. A linked credential (`credential_id` is set)
2. Saved form selectors from a previous successful login (`has_selectors` is true)

If you want automated re-auth later, use `save_credential_as` during your first login flow.
</Note>

### Auth Agent Invocation

An Invocation is a single authentication attempt that belongs to an Auth Agent. You start a new Invocation by calling `kernel.agents.auth.invocations.create(agent.id)`. Over time, an Auth Agent accumulates multiple Invocations as sessions need to be established or refreshed.

**Invocation expires in 5 minutes.** If the user doesn't complete login in time, the invocation status becomes `EXPIRED`.

**Invocation Types:**

- `login` - Authentication flow (used for both first-time login and re-authentication)
- `step_up` - Real-time authentication challenge (coming soon)

### Status Reference

Different endpoints return different status values. Here's the complete reference:

**Invocation status** (from `invocations.retrieve()`):

| Status | Description |
|--------|-------------|
| `IN_PROGRESS` | Invocation is active, user is completing login |
| `SUCCESS` | Login completed successfully, profile is saved |
| `EXPIRED` | Invocation timed out (5 minutes) |
| `CANCELED` | Invocation was explicitly canceled |

**Invocation create response** (from `invocations.create()`):

| Status | Description |
|--------|-------------|
| `INVOCATION_CREATED` | New invocation started, redirect user to `hosted_url` |
| `ALREADY_AUTHENTICATED` | Profile is already logged in, no invocation needed |

**Auth Agent status** (from `agents.auth.retrieve()`):

| Status | Description |
|--------|-------------|
| `AUTHENTICATED` | Profile has a valid logged-in session |
| `NEEDS_AUTH` | Session expired or never logged in |

**Reauth response** (from `agents.auth.reauth()`):

| Status | Description |
|--------|-------------|
| `REAUTH_STARTED` | Automated re-auth started, poll `invocation_id` for completion |
| `ALREADY_AUTHENTICATED` | Session is still valid, no action needed |
| `CANNOT_REAUTH` | Missing credentials or selectors, manual login required |

### Automatic Session Monitoring

Auth Agents with `AUTHENTICATED` status are automatically checked hourly to verify the session is still valid. If the check detects the user has been logged out (session expired, cookies cleared by the site, etc.), the Auth Agent status is updated to `NEEDS_AUTH`.

**How to use this:**

- Poll `kernel.agents.auth.retrieve(id)` periodically to check if re-authentication is needed
- When status changes from `AUTHENTICATED` to `NEEDS_AUTH`:
  - If `can_reauth` is `true`: Call `kernel.agents.auth.reauth(id)` for automated re-auth
  - Otherwise: Trigger a new auth flow with `kernel.agents.auth.invocations.create(agent.id)`
- The check runs passively and doesn't modify the saved profile

### What Discover Does

When you call the discover endpoint on an Invocation, the Auth Agent:

1. Navigates to the target domain (or directly to `login_url` if provided)
2. Finds the login page by looking for sign-in links/buttons
3. Extracts all form input fields on the page (email, password, etc.)
4. Returns the discovered fields with their names, types, labels, and selectors

If the profile is already logged in from a previous session, discover returns `logged_in: true`. At that point, discovery is complete, no fields will be returned, and you should simply proceed to use the associated profile. No credentials or further steps are required.

### What Submit Does

When you call the submit endpoint on an Invocation, the Auth Agent:

1. Fills in the form fields using the `field_values` you provide (matched by field name)
2. Clicks the submit button
3. Waits for the page to respond
4. Analyzes what happened next

The AI determines the outcome by looking at the page after submission:

- **Logged in** - The page shows a logged-in state (dashboard, account page, etc.) → Returns `logged_in: true`
- **Error displayed** - The page shows an error message → Returns `success: false` with `error_message`
- **New fields appeared** - The page now shows different form fields (e.g., OTP input after email/password) → Returns `needs_additional_auth: true` with `additional_fields`

When you get `additional_fields`, collect those values from the user and call submit again. This loop continues until you get `logged_in: true` or an error.

---

## Tips for Early Preview Testing

- **Start simple** - Use the Hosted UI (Option 1) and test with sites that have basic email/password login
- **Provide login_url when known** - Speeds up discovery by skipping the login page search
- **Handle 2FA** - Test flows with 2FA to ensure your integration handles `additional_fields`
- **Poll with backoff** - Start at 2s intervals, increase to 5s. Max timeout is 5 minutes. See polling example below.
- **Clean up profiles** - Delete test profiles with `kernel.profiles.delete(profileName)` when done to avoid clutter
- **Plan for re-auth** - Use `save_credential_as` during initial login to enable automated re-auth later
- **Don't log credentials** - Never log `field_values` or credential data

---

## Support

Questions or issues? Reach out to us on Slack!

---

## Installation (Early Preview)

Before using Agent Auth, install the early preview SDK:

**TypeScript/Node.js:**

```json
{
  "dependencies": {
    "@onkernel/sdk": "https://pkg.stainless.com/s/kernel-typescript/5ace6e2da99e73ad2d863be786213bb9fd28ce53/dist.tar.gz"
  }
}
```

**Python (requirements.txt):**

```
kernel @ https://pkg.stainless.com/s/kernel-python/e7cab450cadd635e0d94db9618e4d729f5d97bcf/kernel-0.23.0-py3-none-any.whl
```

Or in pyproject.toml:

```toml
[project]
dependencies = [
    "kernel @ https://pkg.stainless.com/s/kernel-python/e7cab450cadd635e0d94db9618e4d729f5d97bcf/kernel-0.23.0-py3-none-any.whl"
]
```

---

## Integration Options

<Note>
**Quick Start Examples:** We have standalone example scripts for each integration pattern:
- **Developer Pre-creates Credential** - When you already have user credentials stored
- **Hosted UI Flow** - Redirect users to complete login themselves
- **Programmatic Flow** - Full control over the login process
</Note>

### Option 1: Hosted UI (Recommended)

The simplest approach—redirect users to our hosted authentication UI, then poll for completion.

#### Happy Path in 30 Seconds

```typescript
// 1. Create agent + invocation
const agent = await kernel.agents.auth.create({ target_domain: 'example.com', profile_name: 'user-123' });
const invocation = await kernel.agents.auth.invocations.create({ auth_agent_id: agent.id });

// 2. Redirect user (or skip if ALREADY_AUTHENTICATED)
if (invocation.status !== 'ALREADY_AUTHENTICATED') {
  redirect(invocation.hosted_url);
}

// 3. Poll for completion, then use the profile
const browser = await kernel.browsers.create({ profile: { name: 'user-123' }, stealth: true });
```

#### Hosted UI Redirect Contract

| Question | Answer |
|----------|--------|
| Is `hosted_url` single-use? | No, user can refresh the page |
| Does Kernel redirect back to my app? | No, you must poll for completion |
| How do I detect user abandoned? | Invocation status becomes `EXPIRED` after 5 minutes |
| Can I pass state/return_url? | Not currently supported |

#### Step 1: Start the Auth Flow

```typescript
import { Kernel } from '@onkernel/sdk';

const kernel = new Kernel();

// Step 1: Create or Find Auth Agent
const agent = await kernel.agents.auth.create({
  target_domain: 'netflix.com',
  profile_name: 'netflix-user-123',
  login_url: 'https://netflix.com/login', // Optional: speeds up discovery
  proxy: { proxy_id: 'proxy_abc123' }, // Optional: use a proxy
});

// Step 2: Start the Auth Flow
const invocation = await kernel.agents.auth.invocations.create({
  auth_agent_id: agent.id,
  save_credential_as: 'netflix-creds', // Save credentials for future re-auth
});

// invocation returns: status, invocation_id, hosted_url, handoff_code, expires_at
```

#### Step 2: Redirect User

```typescript
// Check if already logged in
if (invocation.status === 'ALREADY_AUTHENTICATED') {
  console.log('Already logged in! Profile is ready to use.');
  // Skip to Step 4 - Use the Profile
} else {
  // Redirect to hosted flow
  window.location.href = invocation.hosted_url;
}
```

#### Step 3: Poll for Completion

```typescript
// Recommended: Poll with backoff (2s → 3s → 5s), max 5 minutes
async function pollForCompletion(invocationId: string) {
  const maxWaitMs = 5 * 60 * 1000; // 5 minutes
  const start = Date.now();
  let delay = 2000;

  while (Date.now() - start < maxWaitMs) {
    const status = await kernel.agents.auth.invocations.retrieve(invocationId);

    if (status.status === 'SUCCESS') {
      return { success: true, status };
    }
    if (status.status === 'EXPIRED' || status.status === 'CANCELED') {
      return { success: false, reason: status.status };
    }

    await new Promise(r => setTimeout(r, delay));
    delay = Math.min(delay * 1.5, 5000); // Cap at 5s
  }

  return { success: false, reason: 'TIMEOUT' };
}

const result = await pollForCompletion(invocation.invocation_id);

if (result.success) {
  console.log('Success! Profile is ready.');

  // Verify auth agent status
  const authAgent = await kernel.agents.auth.retrieve(agent.id);
  console.log(authAgent.status); // "AUTHENTICATED"
  console.log(authAgent.can_reauth); // true if credentials were saved
}
```

<Warning>
**Don't poll too aggressively.** Use exponential backoff starting at 2 seconds. Invocations typically complete in 10-60 seconds depending on the site and user speed.
</Warning>

#### Step 4: Use the Profile

```typescript
// Create a browser with a saved profile - the user is already logged in!
const browser = await kernel.browsers.create({
  stealth: true,
  profile: {
    name: 'netflix-user-123', // Use the profile name from Step 1
  },
  proxy_id: 'proxy_abc123', // If you used a proxy in Step 1, use the same one here
});

// browser.session_id - Session ID
// browser.cdp_ws_url - CDP URL for Playwright/Puppeteer
// Run your automation - the browser is already authenticated!

// Cleanup when done
await kernel.browsers.deleteByID(browser.session_id);
```

<Warning>
Use `stealth: true` and the same proxy configuration you passed to `kernel.agents.auth.create()`. Agent Auth runs the authentication browser session with stealth mode enabled—mismatched settings may cause unexpected behavior with bot detection or session issues.
</Warning>

#### Step 5: Handle Re-authentication

When sessions expire, check if automated re-auth is available:

```typescript
// Check auth agent status
const agent = await kernel.agents.auth.retrieve(agentId);

if (agent.status === 'NEEDS_AUTH') {
  if (agent.can_reauth) {
    // Automated re-auth (no user interaction needed)
    const reauth = await kernel.agents.auth.reauth(agent.id);

    if (reauth.status === 'REAUTH_STARTED') {
      // Poll for completion using the same backoff pattern
      const result = await pollForCompletion(reauth.invocation_id);
      console.log('Re-auth complete:', result);
    } else if (reauth.status === 'ALREADY_AUTHENTICATED') {
      console.log('Session is still valid');
    } else if (reauth.status === 'CANNOT_REAUTH') {
      // Selectors may have drifted - fall back to manual login
      console.log('Cannot reauth:', reauth.message);
    }
  } else {
    // Manual re-auth required - redirect user to hosted UI
    const invocation = await kernel.agents.auth.invocations.create({
      auth_agent_id: agent.id,
      save_credential_as: 'netflix-creds', // Save credentials this time!
    });
    window.location.href = invocation.hosted_url;
  }
}
```

<Note>
**If reauth fails:** The site's login form may have changed (selectors drifted). Fall back to creating a new invocation for manual login—this will re-capture the updated selectors.
</Note>

---

### Option 2: Custom UI with Discover/Submit APIs

Build your own authentication UI using the lower-level discover and submit APIs. You control the UI, but need to handle the multi-step flow yourself.

#### When to Use Custom UI

- You want login to match your app's design
- You need to collect credentials in your own form
- You're building a native mobile app

#### Step 1: Start the Auth Invocation

```typescript
import { Kernel } from '@onkernel/sdk';

const kernel = new Kernel();

// Step 1: Create Agent & Start Invocation
const agent = await kernel.agents.auth.create({
  target_domain: 'doordash.com',
  profile_name: 'my-profile-123',
});

const invocation = await kernel.agents.auth.invocations.create({
  auth_agent_id: agent.id,
  save_credential_as: 'doordash-creds', // Optional: save for re-auth
});
```

#### Step 2: Exchange Handoff Code for JWT

```typescript
const exchangeResponse = await kernel.agents.auth.invocations.exchange(
  invocation.invocation_id,
  { code: invocation.handoff_code }
);

const jwt = exchangeResponse.jwt; // 30 min TTL
```

#### Step 3: Create JWT-Authenticated Client

```typescript
const jwtKernel = new Kernel({ apiKey: jwt });
```

#### Step 4: Discover Login Fields

```typescript
const discoverResponse = await jwtKernel.agents.auth.invocations.discover(
  invocation.invocation_id,
  {} // Optional: { login_url: 'https://example.com/login' }
);

if (discoverResponse.logged_in) {
  // Already logged in! Profile saved. Skip to using the profile.
}

if (discoverResponse.success && discoverResponse.fields) {
  // Render these fields in your UI
  // Fields are returned in DOM order—display them as-is
}
```

<Note>
**Discover is idempotent.** If the user refreshes or you call discover again, it returns the cached fields from the same invocation. You don't need to store fields—just call discover again to resume.
</Note>

**About discovered fields:**

- Fields are returned in DOM order from the login page
- Currently supports: `text`, `email`, `password`, `tel`, `number`, `code`
- Does NOT include CAPTCHAs, SSO buttons, or "remember me" checkboxes
- `additional_fields` (from submit) may include 2FA codes, security questions, or "select account" prompts—treat them generically as "more fields to fill"

#### Step 5: Map Discovered Fields to Credentials

The discover response returns an array of fields. Each field has a `name` property that you use as the key when submitting credentials.

**Example discover response:**

```json
{
  "success": true,
  "fields": [
    { "name": "email", "type": "email", "label": "Email Address" },
    { "name": "password", "type": "password", "label": "Password" }
  ]
}
```

**To submit, use each field's `name` as the key in `field_values`:**

```json
{
  "field_values": {
    "email": "user@example.com",
    "password": "secretpassword"
  }
}
```

**Recommended mapping strategy:**

```typescript
// Mapping priority:
// 1. Match by field.type (most reliable)
// 2. Match by field.name patterns (fallback)
// 3. Log unmapped fields for debugging

function mapCredentialsToFields(
  fields: Array<{ name: string; type: string }>,
  credentials: { email: string; password: string; code?: string }
): Record<string, string> {
  const fieldValues: Record<string, string> = {};
  const unmapped: string[] = [];

  for (const field of fields) {
    const name = field.name.toLowerCase();
    const type = field.type.toLowerCase();

    // Priority 1: Match by type
    if (type === 'email') {
      fieldValues[field.name] = credentials.email;
    } else if (type === 'password') {
      fieldValues[field.name] = credentials.password;
    } else if (type === 'code') {
      fieldValues[field.name] = credentials.code || '';
    }
    // Priority 2: Match by name patterns
    else if (name.includes('email') || name.includes('user')) {
      fieldValues[field.name] = credentials.email;
    } else if (name.includes('pass')) {
      fieldValues[field.name] = credentials.password;
    } else {
      unmapped.push(field.name);
    }
  }

  // Log unmapped fields for debugging (but never log actual values!)
  if (unmapped.length > 0) {
    console.warn('Unmapped fields:', unmapped);
  }

  return fieldValues;
}

const fieldValues = mapCredentialsToFields(discoverResponse.fields, userCredentials);
```

<Warning>
**Never log `field_values` or credential data.** Only log field names for debugging.
</Warning>

#### Step 6: Submit Credentials (Loop Until Logged In)

```typescript
let submitResponse = await jwtKernel.agents.auth.invocations.submit(
  invocation.invocation_id,
  { field_values: fieldValues }
);

// Handle multi-step auth flows
while (submitResponse.needs_additional_auth && submitResponse.additional_fields) {
  // Map the additional fields the same way
  const additionalValues: Record<string, string> = {};

  for (const field of submitResponse.additional_fields) {
    if (field.type === 'code' || field.name.includes('code') || field.name.includes('otp')) {
      // Prompt user for their 2FA code
      additionalValues[field.name] = await promptUserForOTP();
    } else if (field.type === 'password' || field.name.includes('password')) {
      additionalValues[field.name] = userCredentials.password;
    }
    // Add more mappings as needed
  }

  // Submit again with the new fields
  submitResponse = await jwtKernel.agents.auth.invocations.submit(
    invocation.invocation_id,
    { field_values: additionalValues }
  );
}

// Check final result
if (submitResponse.logged_in) {
  // Success! Profile saved.
}

if (submitResponse.error_message) {
  // Login failed, show error to user
  console.error(submitResponse.error_message);
}
```

**Field mapping tips:**

- Always use `field.name` as the key in `field_values`—this is what the agent uses to match values to form inputs
- Check both `field.type` and `field.name` for matching—some sites use generic types but descriptive names
- Common patterns: `type: "email"` → user's email, `type: "password"` → user's password, `type: "code"` → 2FA/OTP code
- For `additional_fields` with type `code`, you'll typically need to prompt the user in real-time for their 2FA code

---

### Option 3: Programmatic (Headless/Automated)

For bots, service accounts, or automated testing where you provide credentials in code and no user is involved.

#### When to Use Programmatic

- Bot or service accounts with known credentials
- Automated testing/CI pipelines
- Backend-only flows with no user interaction

#### Key Differences from Custom UI

- You provide credentials from environment variables or a secrets manager
- No user prompt for 2FA—you need a TOTP generator or alternate method
- Use API key auth directly (no JWT exchange needed)

```typescript
import { Kernel } from '@onkernel/sdk';

const kernel = new Kernel();

// Credentials from your secrets manager
const CREDS = {
  email: process.env.BOT_EMAIL!,
  password: process.env.BOT_PASSWORD!,
};

// 1. Create agent + invocation
const agent = await kernel.agents.auth.create({
  target_domain: 'example.com',
  profile_name: 'bot-profile',
  login_url: 'https://example.com/login', // Recommended for bots
});

const invocation = await kernel.agents.auth.invocations.create({
  auth_agent_id: agent.id,
  save_credential_as: 'bot-creds', // Enable reauth
});

if (invocation.status === 'ALREADY_AUTHENTICATED') {
  console.log('Already logged in!');
} else {
  // 2. Discover fields (API key auth works, no JWT needed)
  const discover = await kernel.agents.auth.invocations.discover(
    invocation.invocation_id,
    {}
  );

  if (discover.logged_in) {
    console.log('Already logged in during discover!');
  } else if (discover.fields) {
    // 3. Map credentials to fields
    const fieldValues = mapCredentialsToFields(discover.fields, CREDS);

    // 4. Submit
    const result = await kernel.agents.auth.invocations.submit(
      invocation.invocation_id,
      { field_values: fieldValues }
    );

    if (result.logged_in) {
      console.log('Login successful!');
    } else if (result.needs_additional_auth) {
      // Handle 2FA - see note below
      console.log('2FA required:', result.additional_fields);
    }
  }
}

// 5. Use the profile
const browser = await kernel.browsers.create({
  profile: { name: 'bot-profile' },
  stealth: true,
});
```

<Warning>
**2FA with bots:** If the target site requires 2FA, you'll need one of:
- A TOTP generator library (for authenticator app codes)
- Access to the account's email API (for email codes)
- App-specific passwords (if the service supports them)
- A service account without 2FA

If you can't automate 2FA, the programmatic flow won't work for that site.
</Warning>

---

## End-to-End Example: The Complete Lifecycle

Here's a complete example showing the full lifecycle: initial auth, using the profile, detecting session expiry, and re-auth.

```typescript
import { Kernel } from '@onkernel/sdk';

const kernel = new Kernel();

// === INITIAL SETUP (run once per user) ===
async function setupAuth(userId: string, targetDomain: string) {
  const profileName = `user-${userId}-${targetDomain}`;

  // 1. Create agent
  const agent = await kernel.agents.auth.create({
    target_domain: targetDomain,
    profile_name: profileName,
  });

  // 2. Start auth flow
  const invocation = await kernel.agents.auth.invocations.create({
    auth_agent_id: agent.id,
    save_credential_as: `${profileName}-creds`, // Enable future reauth!
  });

  if (invocation.status === 'ALREADY_AUTHENTICATED') {
    return { agentId: agent.id, profileName, ready: true };
  }

  // 3. Return hosted URL for user to complete login
  return {
    agentId: agent.id,
    profileName,
    ready: false,
    hostedUrl: invocation.hosted_url,
    invocationId: invocation.invocation_id,
  };
}

// === USE THE PROFILE (run for each automation) ===
async function runAutomation(agentId: string, profileName: string) {
  // 1. Check if we need to re-auth
  const agent = await kernel.agents.auth.retrieve(agentId);

  if (agent.status === 'NEEDS_AUTH') {
    if (agent.can_reauth) {
      // Automated re-auth
      const reauth = await kernel.agents.auth.reauth(agentId);
      if (reauth.status === 'REAUTH_STARTED') {
        await pollForCompletion(reauth.invocation_id);
      }
    } else {
      throw new Error('Session expired and cannot reauth - user must log in again');
    }
  }

  // 2. Create browser with authenticated profile
  const browser = await kernel.browsers.create({
    profile: { name: profileName },
    stealth: true,
  });

  try {
    // 3. Run your automation
    // const page = await connectPlaywright(browser.cdp_ws_url);
    // await page.goto('https://example.com/dashboard');
    // ... do your work ...

    return { success: true };
  } finally {
    // 4. Always clean up
    await kernel.browsers.deleteByID(browser.session_id);
  }
}

// === HELPER ===
async function pollForCompletion(invocationId: string) {
  const maxWaitMs = 5 * 60 * 1000;
  const start = Date.now();
  let delay = 2000;

  while (Date.now() - start < maxWaitMs) {
    const status = await kernel.agents.auth.invocations.retrieve(invocationId);
    if (status.status !== 'IN_PROGRESS') return status;
    await new Promise(r => setTimeout(r, delay));
    delay = Math.min(delay * 1.5, 5000);
  }
  throw new Error('Timeout waiting for auth');
}
```

**What to store in your database:**

| Data | Permanent? | Purpose |
|------|------------|---------|
| `agentId` | Yes | For reauth, status checks |
| `profileName` | Yes | For creating browsers |
| `invocationId` | No (5 min TTL) | Only while polling for completion |

---

## Credentials API

Store credentials for fully automated re-authentication. Credentials are encrypted at rest and never exposed in API responses.

### Create Credential

```typescript
const credential = await kernel.credentials.create({
  name: 'my-netflix-login',
  domain: 'netflix.com',
  values: {
    email: 'user@example.com',
    password: 'secretpassword',
  },
});
```

### Link Credential to Auth Agent

```typescript
const agent = await kernel.agents.auth.create({
  target_domain: 'netflix.com',
  profile_name: 'my-profile',
  credential_name: credential.name, // Link the credential by name
});
```

### List Credentials

```typescript
const response = await kernel.credentials.list({
  domain: 'netflix.com', // Optional filter
});

// Response is paginated - access items via .items
for (const credential of response.items) {
  console.log(credential.id, credential.name);
}
```

### Delete Credential

```typescript
await kernel.credentials.delete(credentialId);
```

---

## Reauth API

Trigger automated re-authentication when sessions expire.

```typescript
// Check if re-auth is needed
const agent = await kernel.agents.auth.retrieve(agentId);

if (agent.status === 'NEEDS_AUTH' && agent.can_reauth) {
  const reauth = await kernel.agents.auth.reauth(agent.id);

  switch (reauth.status) {
    case 'REAUTH_STARTED':
      console.log('Re-auth in progress:', reauth.invocation_id);
      // Poll for completion...
      break;
    case 'ALREADY_AUTHENTICATED':
      console.log('Session is still valid');
      break;
    case 'CANNOT_REAUTH':
      console.log('Cannot reauth:', reauth.message);
      // Fall back to manual login
      break;
  }
}
```

**Requirements for `can_reauth`:**

- Auth Agent must have a linked credential (`credential_id`)
- Auth Agent must have saved form selectors (`has_selectors`) from a previous successful login

---

## API Reference

### Auth Agents

#### POST /agents/auth

Create or find an auth agent for a domain/profile combination. This is idempotent—calling with the same domain and profile returns the existing agent.

**Auth:** API key

**Request:**

```json
{
  "target_domain": "netflix.com",
  "profile_name": "netflix-user-123",
  "login_url": "https://netflix.com/login",
  "credential_name": "my-netflix-login",
  "proxy": {
    "proxy_id": "proxy_abc123"
  }
}
```

| Parameter | Required | Description |
|-----------|----------|-------------|
| `target_domain` | Yes | Target domain for authentication |
| `profile_name` | Yes | Name of the profile to use |
| `login_url` | No | Login page URL to skip discovery |
| `credential_name` | No | Name of an existing credential to link for auto-fill and re-auth |
| `proxy` | No | Proxy configuration |

**Response:**

```json
{
  "id": "abc123",
  "profile_name": "netflix-user-123",
  "domain": "netflix.com",
  "status": "NEEDS_AUTH",
  "credential_id": "cred_abc123",
  "credential_name": "my-netflix-login",
  "can_reauth": false,
  "has_selectors": false,
  "last_auth_check_at": null
}
```

#### GET /agents/auth/{id}

Get auth agent details and current authentication status.

**Auth:** API key

**Response:**

```json
{
  "id": "abc123",
  "profile_name": "netflix-user-123",
  "domain": "netflix.com",
  "status": "AUTHENTICATED",
  "credential_id": "cred_abc123",
  "credential_name": "my-netflix-login",
  "can_reauth": true,
  "has_selectors": true,
  "last_auth_check_at": "2025-01-15T10:30:00Z"
}
```

#### DELETE /agents/auth/{id}

Delete an auth agent.

**Auth:** API key

**Response:** 204 No Content

<Note>
Deleting an auth agent does not delete the associated browser profile. Use `kernel.profiles.delete(profileName)` to clean up profiles separately.
</Note>

#### GET /agents/auth

List auth agents with optional filters.

**Auth:** API key

**Query Parameters:**

| Parameter | Description |
|-----------|-------------|
| `profile_name` | Filter by profile name |
| `target_domain` | Filter by target domain |
| `limit` | Maximum results (default: 20, max: 100) |
| `offset` | Number of results to skip |

**Response:**

The SDK returns a paginated response object. Access items via the `items` property:

```typescript
const response = await kernel.agents.auth.list({ target_domain: 'netflix.com' });

for (const agent of response.items) {
  console.log(agent.id, agent.status);
}
```

**Raw API Response:**

```json
[
  {
    "id": "abc123",
    "profile_name": "netflix-user-123",
    "domain": "netflix.com",
    "status": "AUTHENTICATED",
    "credential_id": "cred_abc123",
    "credential_name": "my-netflix-login",
    "has_selectors": true,
    "can_reauth": true,
    "last_auth_check_at": "2025-01-15T10:30:00Z"
  }
]
```

**Headers:**
- `X-Has-More`: Whether there are more results
- `X-Next-Offset`: Offset for next page

#### POST /agents/auth/{id}/reauth

Trigger automated re-authentication.

**Auth:** API key

**Response (reauth started):**

```json
{
  "status": "REAUTH_STARTED",
  "invocation_id": "inv_xyz789"
}
```

**Response (already authenticated):**

```json
{
  "status": "ALREADY_AUTHENTICATED"
}
```

**Response (cannot reauth):**

```json
{
  "status": "CANNOT_REAUTH",
  "message": "Missing stored credential or form selectors"
}
```

---

### Auth Agent Invocations

#### POST /agents/auth/invocations

Create an invocation to start an auth flow for an existing auth agent.

**Auth:** API key

**Request:**

```json
{
  "auth_agent_id": "abc123",
  "save_credential_as": "my-saved-creds"
}
```

| Parameter | Required | Description |
|-----------|----------|-------------|
| `auth_agent_id` | Yes | ID of the auth agent |
| `save_credential_as` | No | Save credentials with this name for future re-auth |

**Response (invocation created):**

```json
{
  "status": "INVOCATION_CREATED",
  "invocation_id": "inv_xyz789",
  "handoff_code": "aBcD123EfGh456IjKl789",
  "hosted_url": "https://agent-auth.onkernel.com/agents/auth/invocations/inv_xyz789?code=aBcD123",
  "expires_at": "2025-12-01T12:00:00Z"
}
```

**Response (already logged in - no invocation needed):**

```json
{
  "status": "ALREADY_AUTHENTICATED"
}
```

<Note>
When `status` is `ALREADY_AUTHENTICATED`, the agent is already logged in and no invocation was created. You can proceed directly to using the profile.
</Note>

#### GET /agents/auth/invocations/{invocation_id}

Get invocation status and details.

**Auth:** API key or JWT (from exchange)

**Response:**

```json
{
  "status": "IN_PROGRESS",
  "app_name": "My App",
  "target_domain": "doordash.com",
  "expires_at": "2025-12-01T12:00:00Z"
}
```

| Status | Description |
|--------|-------------|
| `IN_PROGRESS` | User is completing login |
| `SUCCESS` | Login successful, profile saved |
| `EXPIRED` | Invocation timed out |
| `CANCELED` | Invocation was canceled |

#### POST /agents/auth/invocations/{invocation_id}/exchange

Exchange a handoff code for a JWT token.

**Auth:** None (handoff code is the credential)

**Request:**

```json
{
  "code": "aBcD123EfGh456IjKl789"
}
```

**Response:**

```json
{
  "invocation_id": "inv_xyz789",
  "jwt": "eyJhbGciOiJIUzI1NiIs..."
}
```

#### POST /agents/auth/invocations/{invocation_id}/discover

Discover login form fields on the target site.

**Auth:** API key or JWT (from exchange)

**Request:**

```json
{
  "login_url": "https://doordash.com/login"
}
```

| Parameter | Description |
|-----------|-------------|
| `login_url` | Override the stored login URL |

**Response (fields found):**

```json
{
  "success": true,
  "logged_in": false,
  "login_url": "https://identity.doordash.com/auth",
  "page_title": "Sign In - DoorDash",
  "fields": [
    {
      "name": "email",
      "type": "email",
      "label": "Email",
      "placeholder": "Enter your email",
      "required": true,
      "selector": "//input[@id='email']"
    },
    {
      "name": "password",
      "type": "password",
      "label": "Password",
      "required": true,
      "selector": "//input[@id='password']"
    }
  ]
}
```

**Response (already logged in):**

```json
{
  "success": true,
  "logged_in": true
}
```

#### POST /agents/auth/invocations/{invocation_id}/submit

Submit credentials and attempt login.

**Auth:** API key or JWT (from exchange)

**Request:**

```json
{
  "field_values": {
    "email": "user@example.com",
    "password": "********"
  }
}
```

**Response (success):**

```json
{
  "success": true,
  "logged_in": true,
  "app_name": "My App",
  "target_domain": "doordash.com"
}
```

**Response (needs 2FA):**

```json
{
  "success": true,
  "logged_in": false,
  "needs_additional_auth": true,
  "additional_fields": [
    {
      "name": "code",
      "type": "code",
      "label": "Verification Code",
      "required": true,
      "selector": "//input[@name='code']"
    }
  ]
}
```

**Response (error):**

```json
{
  "success": false,
  "logged_in": false,
  "error_message": "Incorrect email or password"
}
```

---

### Credentials

#### POST /credentials

Create a new credential.

**Auth:** API key

**Request:**

```json
{
  "name": "my-netflix-login",
  "domain": "netflix.com",
  "values": {
    "email": "user@example.com",
    "password": "secretpassword"
  }
}
```

| Parameter | Required | Description |
|-----------|----------|-------------|
| `name` | Yes | Unique name within your organization |
| `domain` | Yes | Target domain |
| `values` | Yes | Key-value pairs of credential fields |

**Response:**

```json
{
  "id": "cred_abc123",
  "name": "my-netflix-login",
  "domain": "netflix.com",
  "created_at": "2025-01-15T10:30:00Z",
  "updated_at": "2025-01-15T10:30:00Z"
}
```

<Warning>
Credential values are write-only and never returned in API responses.
</Warning>

#### GET /credentials

List credentials.

**Auth:** API key

**Query Parameters:**

| Parameter | Description |
|-----------|-------------|
| `domain` | Filter by domain |
| `limit` | Maximum results (default: 20, max: 100) |
| `offset` | Number of results to skip |

#### GET /credentials/{id}

Get credential metadata (values not returned).

#### PATCH /credentials/{id}

Update a credential.

**Request:**

```json
{
  "name": "updated-name",
  "values": {
    "email": "newemail@example.com",
    "password": "newpassword"
  }
}
```

#### DELETE /credentials/{id}

Delete a credential.

---

### Field Types

| Type | Description |
|------|-------------|
| `text` | Generic text input |
| `email` | Email address |
| `password` | Password (masked) |
| `tel` | Phone number |
| `number` | Numeric input |
| `url` | URL input |
| `code` | Verification code (OTP, 2FA) |

---

## Security

| Feature | Description |
|---------|-------------|
| **Credentials encrypted at rest** | All credential values are encrypted using per-organization keys |
| **Credentials never exposed** | Values are write-only and never returned in API responses |
| **Credentials never shared with LLMs** | Values are submitted programmatically directly to the target site |
| **Short-lived tokens** | JWT tokens expire after 30 minutes |
| **Handoff codes expire** | One-time use, expire after 5 minutes |
| **Profile encryption** | Browser profiles are encrypted at rest |
| **Isolated execution** | Each auth flow runs in an isolated browser environment |

### FAQ

**Does Kernel see my users' credentials?**

Yes, when you use `submit()`, credentials pass through Kernel's servers to fill the form on the target site. They are:
- Encrypted in transit (TLS)
- Never logged or persisted beyond the immediate use
- Never passed to AI/LLM models
- Used only to fill form fields and click submit

**Can I delete or rotate credentials?**

Yes. Use `kernel.credentials.delete(id)` to delete, or `kernel.credentials.update(id, { values: {...} })` to rotate.

**What if `save_credential_as` captures the wrong fields?**

The credential captures whatever `field_values` you submit. If you submit extra fields or wrong mappings, those get saved. You can update or delete the credential and try again.

**Should I log `field_values` for debugging?**

Never log credential values. Log only field names if you need to debug mapping issues.
