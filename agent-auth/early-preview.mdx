---
title: "Early Preview"
description: "Agent Auth early preview documentation for testers"
---

<Warning>
This is early preview documentation for Agent Auth testers. Features and APIs may change before general availability.
</Warning>

## What is Agent Auth?

Agent Auth is an AI-powered authentication system that helps you log users into any website and save their authenticated browser session (profile) for future automations. It uses web agents to intelligently discover login forms, dynamically generate credential inputs, and handle multi-step authentication flows like 2FA/OTP.

**Key features:**

- Automatically detects login form fields on any website
- Dynamically generates forms based on discovered fields
- Handles multi-step auth (2FA, OTP, magic links)
- Saves authenticated browser profiles for reuse
- Hourly session checks to detect when re-authentication is needed
- Credentials are encrypted and submitted programmatically—never stored in plaintext or shared with LLMs
- **NEW:** Store credentials for fully automated re-authentication
- **NEW:** `reauth()` endpoint for programmatic session refresh

## How It Works

1. Your backend calls `kernel.agents.auth.create()` to setup the agent, then calls `kernel.agents.auth.invocations.create()` to start the flow → Returns `invocation_id`, `hosted_url`, `handoff_code`, and `expires_at`
2. User is redirected to `hosted_url` → Enters credentials when prompted → Handles 2FA/OTP if needed → Profile saved on success
3. Your backend polls invocation status → Uses saved profile in future browser automations
4. After authentication completes, Agent Auth automatically monitors the session every hour and updates the status if re-authentication is required
5. **NEW:** If credentials are stored, Agent Auth can automatically re-authenticate when sessions expire

## Key Concepts

### Auth Agent

An Auth Agent is a persistent entity that manages authentication for a specific domain + profile combination. You create or retrieve Auth Agents using `kernel.agents.auth.create()`. This method is idempotent—if an agent already exists for the domain and profile, it returns the existing one.

The Auth Agent stores:

- The target domain (e.g., `doordash.com`)
- The linked browser profile
- The login URL (learned during discovery, used to speed up future invocations)
- The auth check URL (where to verify logged-in state)
- Current authentication status (`AUTHENTICATED` or `NEEDS_AUTH`)
- **NEW:** Linked credential ID for automated re-auth
- **NEW:** Saved form selectors for deterministic re-auth

**New Auth Agent fields:**

| Field | Description |
|-------|-------------|
| `credential_id` | ID of linked credential (if any) |
| `credential_name` | Name of linked credential (if any) |
| `can_reauth` | `true` if agent has both credentials and selectors for automated re-auth |
| `has_selectors` | `true` if form selectors were saved from a previous login |
| `last_auth_check_at` | When the last session health check was performed |

### Auth Agent Invocation

An Invocation is a single authentication attempt that belongs to an Auth Agent. You start a new Invocation by calling `kernel.agents.auth.invocations.create(agent.id)`. Over time, an Auth Agent accumulates multiple Invocations as sessions need to be established or refreshed.

**Invocation Types:**

- `login` - Authentication flow (used for both first-time login and re-authentication)
- `step_up` - Real-time authentication challenge (coming soon)

**Invocation Statuses:**

| Status | Description |
|--------|-------------|
| `IN_PROGRESS` | Invocation is in progress |
| `SUCCESS` | Invocation completed successfully, profile is saved |
| `EXPIRED` | Invocation timed out before user completed authentication |
| `CANCELED` | Invocation was explicitly canceled |

### Automatic Session Monitoring

Auth Agents with `AUTHENTICATED` status are automatically checked hourly to verify the session is still valid. If the check detects the user has been logged out (session expired, cookies cleared by the site, etc.), the Auth Agent status is updated to `NEEDS_AUTH`.

**How to use this:**

- Poll `kernel.agents.auth.retrieve(id)` periodically to check if re-authentication is needed
- When status changes from `AUTHENTICATED` to `NEEDS_AUTH`:
  - If `can_reauth` is `true`: Call `kernel.agents.auth.reauth(id)` for automated re-auth
  - Otherwise: Trigger a new auth flow with `kernel.agents.auth.invocations.create(agent.id)`
- The check runs passively and doesn't modify the saved profile

**Status meanings:**

| Status | Description |
|--------|-------------|
| `AUTHENTICATED` | Profile has a valid logged-in session, ready for use |
| `NEEDS_AUTH` | Session is no longer valid, re-authentication required |

### What Discover Does

When you call the discover endpoint on an Invocation, the Auth Agent:

1. Navigates to the target domain (or directly to `login_url` if provided)
2. Finds the login page by looking for sign-in links/buttons
3. Extracts all form input fields on the page (email, password, etc.)
4. Returns the discovered fields with their names, types, labels, and selectors

If the profile is already logged in from a previous session, discover returns `logged_in: true`. At that point, discovery is complete, no fields will be returned, and you should simply proceed to use the associated profile. No credentials or further steps are required.

### What Submit Does

When you call the submit endpoint on an Invocation, the Auth Agent:

1. Fills in the form fields using the `field_values` you provide (matched by field name)
2. Clicks the submit button
3. Waits for the page to respond
4. Analyzes what happened next

The AI determines the outcome by looking at the page after submission:

- **Logged in** - The page shows a logged-in state (dashboard, account page, etc.) → Returns `logged_in: true`
- **Error displayed** - The page shows an error message → Returns `success: false` with `error_message`
- **New fields appeared** - The page now shows different form fields (e.g., OTP input after email/password) → Returns `needs_additional_auth: true` with `additional_fields`

When you get `additional_fields`, collect those values from the user and call submit again. This loop continues until you get `logged_in: true` or an error.

---

## Tips for Early Preview Testing

- **Start simple** - Use the Hosted UI (Option 1) and test with sites that have basic email/password login
- **Provide login_url when known** - Speeds up discovery by skipping the login page search
- **Handle 2FA** - Test flows with 2FA to ensure your integration handles `additional_fields`
- **Poll appropriately** - Poll every 2 seconds, with a max timeout of 5 minutes
- **Clean up profiles** - Delete test profiles with `kernel.profiles.delete(profileName)` when done to avoid clutter
- **Test re-auth** - Use `save_credential_as` to save credentials, then test the `reauth()` flow

---

## Support

Questions or issues? Reach out to us on Slack!

---

## Installation (Early Preview)

Before using Agent Auth, install the early preview SDK:

**TypeScript/Node.js:**

```json
{
  "dependencies": {
    "@onkernel/kernel": "^0.23.0"
  }
}
```

**Python (requirements.txt):**

```
kernel==0.23.0
```

Or in pyproject.toml:

```toml
[project]
dependencies = [
    "kernel==0.23.0"
]
```

---

## Integration Options

<Note>
**Quick Start Examples:** We have standalone example scripts for each integration pattern:
- [Dev Pre-creates Credential](https://gist.github.com/masonweld/agent-auth-dev-credentials) - When you already have user credentials stored
- [Hosted UI Flow](https://gist.github.com/masonweld/agent-auth-hosted-ui) - Redirect users to complete login themselves
- [Programmatic Flow](https://gist.github.com/masonweld/agent-auth-programmatic) - Full control over the login process
</Note>

### Option 1: Hosted UI (Recommended)

The simplest approach—redirect users to our hosted authentication UI, then poll for completion.

#### Step 1: Start the Auth Flow

```typescript
import { Kernel } from '@onkernel/sdk';

const kernel = new Kernel();

// Step 1: Create or Find Auth Agent
const agent = await kernel.agents.auth.create({
  target_domain: 'netflix.com',
  profile_name: 'netflix-user-123',
  login_url: 'https://netflix.com/login', // Optional: speeds up discovery
  proxy: { proxy_id: 'proxy_abc123' }, // Optional: use a proxy
});

// Step 2: Start the Auth Flow
const invocation = await kernel.agents.auth.invocations.create({
  auth_agent_id: agent.id,
  save_credential_as: 'netflix-creds', // NEW: Save credentials for future re-auth
});

// invocation returns: status, invocation_id, hosted_url, handoff_code, expires_at
```

#### Step 2: Redirect User

```typescript
// Check if already logged in
if (invocation.status === 'already_authenticated') {
  console.log('Already logged in! Profile is ready to use.');
  // Skip to Step 4 - Use the Profile
} else {
  // Redirect to hosted flow
  window.location.href = invocation.hosted_url;
}
```

#### Step 3: Poll for Completion

```typescript
const polledInvocation = await kernel.agents.auth.invocations.retrieve(
  invocation.invocation_id
);

// invocation.status is one of: IN_PROGRESS, SUCCESS, EXPIRED, CANCELED

if (polledInvocation.status === 'SUCCESS') {
  console.log('Success! Profile is ready.');

  // Verify auth agent status
  const authAgent = await kernel.agents.auth.retrieve(agent.id);
  console.log(authAgent.status); // "AUTHENTICATED"
  console.log(authAgent.can_reauth); // true if credentials were saved
}
```

#### Step 4: Use the Profile

```typescript
// Create a browser with a saved profile - the user is already logged in!
const browser = await kernel.browsers.create({
  stealth: true,
  profile: {
    name: 'netflix-user-123', // Use the profile name from Step 1
  },
  proxy_id: 'proxy_abc123', // If you used a proxy in Step 1, use the same one here
});

// browser.session_id - Session ID
// browser.cdp_ws_url - CDP URL for Playwright/Puppeteer
// Run your automation - the browser is already authenticated!

// Cleanup when done
await kernel.browsers.deleteByID(browser.session_id);
```

<Warning>
Use `stealth: true` and the same proxy configuration you passed to `kernel.agents.auth.create()`. Agent Auth runs the authentication browser session with stealth mode enabled—mismatched settings may cause unexpected behavior with bot detection or session issues.
</Warning>

#### NEW: Step 5: Handle Re-authentication

When sessions expire, check if automated re-auth is available:

```typescript
// Check auth agent status
const agent = await kernel.agents.auth.retrieve(agentId);

if (agent.status === 'NEEDS_AUTH') {
  if (agent.can_reauth) {
    // Automated re-auth (no user interaction needed)
    const reauth = await kernel.agents.auth.reauth(agent.id);

    if (reauth.status === 'reauth_started') {
      // Poll for completion
      let status = await kernel.agents.auth.invocations.retrieve(reauth.invocation_id);
      while (status.status === 'IN_PROGRESS') {
        await new Promise(r => setTimeout(r, 2000));
        status = await kernel.agents.auth.invocations.retrieve(reauth.invocation_id);
      }
      console.log('Re-auth complete:', status.status);
    }
  } else {
    // Manual re-auth required - redirect user to hosted UI
    const invocation = await kernel.agents.auth.invocations.create({
      auth_agent_id: agent.id,
      save_credential_as: 'netflix-creds', // Save credentials this time
    });
    window.location.href = invocation.hosted_url;
  }
}
```

---

### Option 2: Custom UI with Discover/Submit APIs

Build your own authentication UI using the lower-level discover and submit APIs. You'll need to handle the multi-step flow yourself.

#### Step 1: Start the Auth Invocation

```typescript
import { Kernel } from '@onkernel/sdk';

const kernel = new Kernel();

// Step 1: Create Agent & Start Invocation
const agent = await kernel.agents.auth.create({
  target_domain: 'doordash.com',
  profile_name: 'my-profile-123',
});

const invocation = await kernel.agents.auth.invocations.create({
  auth_agent_id: agent.id,
  save_credential_as: 'doordash-creds', // Optional: save for re-auth
});
```

#### Step 2: Exchange Handoff Code for JWT

```typescript
const exchangeResponse = await kernel.agents.auth.invocations.exchange(
  invocation.invocation_id,
  { code: invocation.handoff_code }
);

const jwt = exchangeResponse.jwt; // 30 min TTL
```

#### Step 3: Create JWT-Authenticated Client

```typescript
const jwtKernel = new Kernel({ apiKey: jwt });
```

#### Step 4: Discover Login Fields

```typescript
const discoverResponse = await jwtKernel.agents.auth.invocations.discover(
  invocation.invocation_id,
  {} // Optional: { login_url: 'https://example.com/login' }
);

if (discoverResponse.logged_in) {
  // Already logged in! Profile saved.
}

if (discoverResponse.success && discoverResponse.fields) {
  // Show these fields to the user in your UI
}
```

#### Step 5: Map Discovered Fields to Credentials

The discover response returns an array of fields. Each field has a `name` property that you use as the key when submitting credentials.

**Example discover response:**

```json
{
  "success": true,
  "fields": [
    { "name": "email", "type": "email", "label": "Email Address" },
    { "name": "password", "type": "password", "label": "Password" }
  ]
}
```

**To submit, use each field's `name` as the key in `field_values`:**

```json
{
  "field_values": {
    "email": "user@example.com",
    "password": "secretpassword"
  }
}
```

**Mapping strategy:** Use the field's type and name to determine what credential to provide:

```typescript
// You have the user's credentials stored somewhere
const userCredentials = {
  email: 'user@example.com',
  password: 'secretpassword',
};

// Build field_values by mapping each discovered field
const fieldValues: Record<string, string> = {};

for (const field of discoverResponse.fields) {
  // Use field.type and field.name to determine the value
  if (field.type === 'email' || field.name.includes('email')) {
    fieldValues[field.name] = userCredentials.email;
  } else if (field.type === 'password' || field.name.includes('password')) {
    fieldValues[field.name] = userCredentials.password;
  } else if (field.name.includes('username')) {
    fieldValues[field.name] = userCredentials.email; // Often email is the username
  }
}
// fieldValues is now: { "email": "user@example.com", "password": "secretpassword" }
```

#### Step 6: Submit Credentials (Loop Until Logged In)

```typescript
let submitResponse = await jwtKernel.agents.auth.invocations.submit(
  invocation.invocation_id,
  { field_values: fieldValues }
);

// Handle multi-step auth flows
while (submitResponse.needs_additional_auth && submitResponse.additional_fields) {
  // Map the additional fields the same way
  const additionalValues: Record<string, string> = {};

  for (const field of submitResponse.additional_fields) {
    if (field.type === 'code' || field.name.includes('code') || field.name.includes('otp')) {
      // Prompt user for their 2FA code
      additionalValues[field.name] = await promptUserForOTP();
    } else if (field.type === 'password' || field.name.includes('password')) {
      additionalValues[field.name] = userCredentials.password;
    }
    // Add more mappings as needed
  }

  // Submit again with the new fields
  submitResponse = await jwtKernel.agents.auth.invocations.submit(
    invocation.invocation_id,
    { field_values: additionalValues }
  );
}

// Check final result
if (submitResponse.logged_in) {
  // Success! Profile saved.
}

if (submitResponse.error_message) {
  // Login failed, show error to user
  console.error(submitResponse.error_message);
}
```

**Field mapping tips:**

- Always use `field.name` as the key in `field_values`—this is what the agent uses to match values to form inputs
- Check both `field.type` and `field.name` for matching—some sites use generic types but descriptive names
- Common patterns: `type: "email"` → user's email, `type: "password"` → user's password, `type: "code"` → 2FA/OTP code
- For `additional_fields` with type `code`, you'll typically need to prompt the user in real-time for their 2FA code

---

## NEW: Credentials API

Store credentials for fully automated re-authentication. Credentials are encrypted at rest and never exposed in API responses.

### Create Credential

```typescript
const credential = await kernel.credentials.create({
  name: 'my-netflix-login',
  domain: 'netflix.com',
  values: {
    email: 'user@example.com',
    password: 'secretpassword',
  },
});
```

### Link Credential to Auth Agent

```typescript
const agent = await kernel.agents.auth.create({
  target_domain: 'netflix.com',
  profile_name: 'my-profile',
  credential_name: credential.name, // Link the credential by name
});
```

### List Credentials

```typescript
const response = await kernel.credentials.list({
  domain: 'netflix.com', // Optional filter
});

// Response is paginated - access items via .items
for (const credential of response.items) {
  console.log(credential.id, credential.name);
}
```

### Delete Credential

```typescript
await kernel.credentials.delete(credentialId);
```

---

## NEW: Reauth API

Trigger automated re-authentication when sessions expire.

```typescript
// Check if re-auth is needed
const agent = await kernel.agents.auth.retrieve(agentId);

if (agent.status === 'NEEDS_AUTH' && agent.can_reauth) {
  const reauth = await kernel.agents.auth.reauth(agent.id);

  switch (reauth.status) {
    case 'reauth_started':
      console.log('Re-auth in progress:', reauth.invocation_id);
      // Poll for completion...
      break;
    case 'already_authenticated':
      console.log('Session is still valid');
      break;
    case 'cannot_reauth':
      console.log('Cannot reauth:', reauth.message);
      // Fall back to manual login
      break;
  }
}
```

**Requirements for `can_reauth`:**
- Auth Agent must have a linked credential (`credential_id`)
- Auth Agent must have saved form selectors (`has_selectors`) from a previous successful login

---

## API Reference

### Auth Agents

#### POST /agents/auth

Create or find an auth agent for a domain/profile combination. This is idempotent—calling with the same domain and profile returns the existing agent.

**Auth:** API key

**Request:**

```json
{
  "target_domain": "netflix.com",
  "profile_name": "netflix-user-123",
  "login_url": "https://netflix.com/login",
  "credential_name": "my-netflix-login",
  "proxy": {
    "proxy_id": "proxy_abc123"
  }
}
```

| Parameter | Required | Description |
|-----------|----------|-------------|
| `target_domain` | Yes | Target domain for authentication |
| `profile_name` | Yes | Name of the profile to use |
| `login_url` | No | Login page URL to skip discovery |
| `credential_name` | No | **NEW:** Name of an existing credential to link for auto-fill and re-auth |
| `proxy` | No | Proxy configuration |

**Response:**

```json
{
  "id": "abc123",
  "profile_name": "netflix-user-123",
  "domain": "netflix.com",
  "status": "NEEDS_AUTH",
  "credential_id": "cred_abc123",
  "credential_name": "my-netflix-login",
  "can_reauth": false,
  "has_selectors": false,
  "last_auth_check_at": null
}
```

#### GET /agents/auth/{id}

Get auth agent details and current authentication status.

**Auth:** API key

**Response:**

```json
{
  "id": "abc123",
  "profile_name": "netflix-user-123",
  "domain": "netflix.com",
  "status": "AUTHENTICATED",
  "credential_id": "cred_abc123",
  "credential_name": "my-netflix-login",
  "can_reauth": true,
  "has_selectors": true,
  "last_auth_check_at": "2025-01-15T10:30:00Z"
}
```

#### DELETE /agents/auth/{id}

Delete an auth agent.

**Auth:** API key

**Response:** 204 No Content

<Note>
Deleting an auth agent does not delete the associated browser profile. Use `kernel.profiles.delete(profileName)` to clean up profiles separately.
</Note>

#### GET /agents/auth

List auth agents with optional filters.

**Auth:** API key

**Query Parameters:**

| Parameter | Description |
|-----------|-------------|
| `profile_name` | Filter by profile name |
| `target_domain` | Filter by target domain |
| `limit` | Maximum results (default: 20, max: 100) |
| `offset` | Number of results to skip |

**Response:**

The SDK returns a paginated response object. Access items via the `items` property:

```typescript
const response = await kernel.agents.auth.list({ target_domain: 'netflix.com' });

for (const agent of response.items) {
  console.log(agent.id, agent.status);
}
```

**Raw API Response:**

```json
[
  {
    "id": "abc123",
    "profile_name": "netflix-user-123",
    "domain": "netflix.com",
    "status": "AUTHENTICATED",
    "credential_id": "cred_abc123",
    "credential_name": "my-netflix-login",
    "has_selectors": true,
    "can_reauth": true,
    "last_auth_check_at": "2025-01-15T10:30:00Z"
  }
]
```

**Headers:**
- `X-Has-More`: Whether there are more results
- `X-Next-Offset`: Offset for next page

#### POST /agents/auth/{id}/reauth

**NEW:** Trigger automated re-authentication.

**Auth:** API key

**Response (reauth started):**

```json
{
  "status": "reauth_started",
  "invocation_id": "inv_xyz789"
}
```

**Response (already authenticated):**

```json
{
  "status": "already_authenticated"
}
```

**Response (cannot reauth):**

```json
{
  "status": "cannot_reauth",
  "message": "Missing stored credential or form selectors"
}
```

---

### Auth Agent Invocations

#### POST /agents/auth/invocations

Create an invocation to start an auth flow for an existing auth agent.

**Auth:** API key

**Request:**

```json
{
  "auth_agent_id": "abc123",
  "save_credential_as": "my-saved-creds"
}
```

| Parameter | Required | Description |
|-----------|----------|-------------|
| `auth_agent_id` | Yes | ID of the auth agent |
| `save_credential_as` | No | **NEW:** Save credentials with this name for future re-auth |

**Response (invocation created):**

```json
{
  "status": "invocation_created",
  "invocation_id": "inv_xyz789",
  "handoff_code": "aBcD123EfGh456IjKl789",
  "hosted_url": "https://agent-auth.onkernel.com/agents/auth/invocations/inv_xyz789?code=aBcD123",
  "expires_at": "2025-12-01T12:00:00Z"
}
```

**Response (already logged in - no invocation needed):**

```json
{
  "status": "already_authenticated"
}
```

<Note>
When `status` is `already_authenticated`, the agent is already logged in and no invocation was created. You can proceed directly to using the profile.
</Note>

#### GET /agents/auth/invocations/{invocation_id}

Get invocation status and details.

**Auth:** JWT (from exchange) or API key

**Response:**

```json
{
  "status": "IN_PROGRESS",
  "app_name": "My App",
  "target_domain": "doordash.com",
  "expires_at": "2025-12-01T12:00:00Z"
}
```

| Status | Description |
|--------|-------------|
| `IN_PROGRESS` | User is completing login |
| `SUCCESS` | Login successful, profile saved |
| `EXPIRED` | Invocation timed out |
| `CANCELED` | Invocation was canceled |

#### POST /agents/auth/invocations/{invocation_id}/exchange

Exchange a handoff code for a JWT token.

**Auth:** None (handoff code is the credential)

**Request:**

```json
{
  "code": "aBcD123EfGh456IjKl789"
}
```

**Response:**

```json
{
  "invocation_id": "inv_xyz789",
  "jwt": "eyJhbGciOiJIUzI1NiIs..."
}
```

#### POST /agents/auth/invocations/{invocation_id}/discover

Discover login form fields on the target site.

**Auth:** JWT (from exchange)

**Request:**

```json
{
  "login_url": "https://doordash.com/login"
}
```

| Parameter | Description |
|-----------|-------------|
| `login_url` | Override the stored login URL |

**Response (fields found):**

```json
{
  "success": true,
  "logged_in": false,
  "login_url": "https://identity.doordash.com/auth",
  "page_title": "Sign In - DoorDash",
  "fields": [
    {
      "name": "email",
      "type": "email",
      "label": "Email",
      "placeholder": "Enter your email",
      "required": true,
      "selector": "//input[@id='email']"
    },
    {
      "name": "password",
      "type": "password",
      "label": "Password",
      "required": true,
      "selector": "//input[@id='password']"
    }
  ]
}
```

**Response (already logged in):**

```json
{
  "success": true,
  "logged_in": true
}
```

#### POST /agents/auth/invocations/{invocation_id}/submit

Submit credentials and attempt login.

**Auth:** JWT (from exchange)

**Request:**

```json
{
  "field_values": {
    "email": "user@example.com",
    "password": "********"
  }
}
```

**Response (success):**

```json
{
  "success": true,
  "logged_in": true,
  "app_name": "My App",
  "target_domain": "doordash.com"
}
```

**Response (needs 2FA):**

```json
{
  "success": true,
  "logged_in": false,
  "needs_additional_auth": true,
  "additional_fields": [
    {
      "name": "code",
      "type": "code",
      "label": "Verification Code",
      "required": true,
      "selector": "//input[@name='code']"
    }
  ]
}
```

**Response (error):**

```json
{
  "success": false,
  "logged_in": false,
  "error_message": "Incorrect email or password"
}
```

---

### Credentials

#### POST /credentials

Create a new credential.

**Auth:** API key

**Request:**

```json
{
  "name": "my-netflix-login",
  "domain": "netflix.com",
  "values": {
    "email": "user@example.com",
    "password": "secretpassword"
  }
}
```

| Parameter | Required | Description |
|-----------|----------|-------------|
| `name` | Yes | Unique name within your organization |
| `domain` | Yes | Target domain |
| `values` | Yes | Key-value pairs of credential fields |

**Response:**

```json
{
  "id": "cred_abc123",
  "name": "my-netflix-login",
  "domain": "netflix.com",
  "created_at": "2025-01-15T10:30:00Z",
  "updated_at": "2025-01-15T10:30:00Z"
}
```

<Warning>
Credential values are write-only and never returned in API responses.
</Warning>

#### GET /credentials

List credentials.

**Auth:** API key

**Query Parameters:**

| Parameter | Description |
|-----------|-------------|
| `domain` | Filter by domain |
| `limit` | Maximum results (default: 20, max: 100) |
| `offset` | Number of results to skip |

#### GET /credentials/{id}

Get credential metadata (values not returned).

#### PATCH /credentials/{id}

Update a credential.

**Request:**

```json
{
  "name": "updated-name",
  "values": {
    "email": "newemail@example.com",
    "password": "newpassword"
  }
}
```

#### DELETE /credentials/{id}

Delete a credential.

---

### Field Types

| Type | Description |
|------|-------------|
| `text` | Generic text input |
| `email` | Email address |
| `password` | Password (masked) |
| `tel` | Phone number |
| `number` | Numeric input |
| `url` | URL input |
| `code` | Verification code (OTP, 2FA) |

---

## Security

| Feature | Description |
|---------|-------------|
| **Credentials encrypted at rest** | All credential values are encrypted using per-organization keys |
| **Credentials never exposed** | Values are write-only and never returned in API responses |
| **Credentials never shared with LLMs** | Values are submitted programmatically directly to the target site |
| **Short-lived tokens** | JWT tokens expire after 30 minutes |
| **Handoff codes expire** | One-time use, expire after 5 minutes |
| **Profile encryption** | Browser profiles are encrypted at rest |
| **Isolated execution** | Each auth flow runs in an isolated browser environment |
