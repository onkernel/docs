---
title: "Hosted UI"
description: "The simplest way to authenticate AI agents"
---

Our Hosted UI flow is the recommended approach for most applications. Your application redirects users to a Kernel-hosted authentication page where they complete the login process. Then, you can poll for completion.

Use the Hosted UI when:
- Building user-facing applications where the user can complete login
- You want Kernel to handle the login UI and form discovery
- You need a quick integration with minimal code
- You want to avoid handling multi-step auth flows yourself

## Getting started

### 1. Create an Auth Agent

An Auth Agent represents a (domain, [profile](/browsers/profiles)) pair. Creating one is idempotentâ€”if an agent already exists for the domain and profile, it returns the existing one.

```typescript
const agent = await kernel.agents.auth.create({
  target_domain: 'example.com',      // Required: domain to authenticate
  profile_name: 'my-profile',        // Required: name a profile to store the auth session
  login_url: 'https://example.com/login', // Optional: speeds up discovery
});
```

### 2. Start an Invocation

An invocation starts a new authentication attempt. It returns a `hosted_url` where the user completes login.

```typescript
const invocation = await kernel.agents.auth.invocations.create({
  auth_agent_id: agent.id,
});
```

Enable automatic re-authentication when sessions expire with the `save_credential_as` field. When set, the Auth Agent automatically re-authenticates without additional user interaction (see [FAQ](/agent-auth/faq)). 

```typescript
const invocation = await kernel.agents.auth.invocations.create({
  auth_agent_id: agent.id,
  save_credential_as: 'my-saved-creds', // Set identifier to enable automatic re-auth
});
```

<Info>
If the response returns `logged_in` as `true`, the profile is already authenticated. Skip the redirect and go straight to using the profile.
</Info>

### 3. Redirect the User

In a web application, redirect the user to the hosted URL:

```typescript
// Frontend code
window.location.href = invocation.hosted_url;
```

The hosted UI will:
1. Navigate to the target domain
2. Find and display the login form
3. Let the user enter credentials
4. Handle multi-step auth (2FA, OTP, etc.)
5. Save the authenticated session to the profile

### 4. Poll for Completion

On your backend, poll the invocation status until it completes:

```typescript
let status = await kernel.agents.auth.invocations.retrieve(invocation.invocation_id);

while (status.status === 'IN_PROGRESS') {
  await new Promise(r => setTimeout(r, 2000)); // Poll every 2 seconds
  status = await kernel.agents.auth.invocations.retrieve(invocation.invocation_id);
}

switch (status.status) {
  case 'SUCCESS':
    console.log('Authentication successful!');
    break;
  case 'EXPIRED':
    console.log('User did not complete login in time');
    break;
  case 'CANCELED':
    console.log('Authentication was canceled');
    break;
}
```

<Info>
Poll every 2 seconds with a maximum timeout of 5 minutes. The invocation expires after 5 minutes if not completed.
</Info>

### 5. Use the Authenticated Profile

Once authentication succeeds, create browsers with the profile to get an already logged-in session:

```typescript
const browser = await kernel.browsers.create({
  profile: { name: 'my-profile' },
  stealth: true,
});

// Connect with Playwright
import { chromium } from 'playwright';
const playwrightBrowser = await chromium.connectOverCDP(browser.cdp_ws_url);
const page = playwrightBrowser.contexts()[0].pages()[0];

// Navigate - you're already logged in!
await page.goto('https://example.com/dashboard');
```

<Info>
Use `stealth: true` when creating browsers for authenticated sessions. Agent Auth runs authentication with stealth mode enabled, and mismatched settings may cause issues with bot detection.
</Info>


## Complete Example

<CodeGroup>
```typescript TypeScript
import Kernel from '@onkernel/sdk';

const kernel = new Kernel();

// Step 1: Create or get existing Auth Agent
const agent = await kernel.agents.auth.create({
  target_domain: 'doordash.com',
  profile_name: 'doordash-user-123',
  login_url: 'https://identity.doordash.com/auth', // Optional: speeds up discovery
});

// Step 2: Start the auth flow
const invocation = await kernel.agents.auth.invocations.create({
  auth_agent_id: agent.id,
});

// Step 3: Check if already logged in
if (invocation.status === 'ALREADY_AUTHENTICATED') {
  console.log('Already authenticated! Profile is ready to use.');
  // Skip to Step 6: Use the Profile
} else {
  // Redirect user to hosted UI
  console.log('Redirect user to:', invocation.hosted_url);
  // In a web app: window.location.href = invocation.hosted_url;
}

// Step 4: Poll for completion (do this on your backend)
const pollForCompletion = async (invocationId: string) => {
  const maxWaitMs = 5 * 60 * 1000; // 5 minutes
  const startTime = Date.now();

  while (Date.now() - startTime < maxWaitMs) {
    const status = await kernel.agents.auth.invocations.retrieve(invocationId);

    if (status.status === 'SUCCESS') {
      return { success: true };
    }
    if (status.status === 'EXPIRED' || status.status === 'CANCELED') {
      return { success: false, reason: status.status };
    }

    // Poll every 2 seconds
    await new Promise(r => setTimeout(r, 2000));
  }

  return { success: false, reason: 'TIMEOUT' };
};

const result = await pollForCompletion(invocation.invocation_id);

// Step 5: Verify the auth agent status
if (result.success) {
  const authAgent = await kernel.agents.auth.retrieve(agent.id);
  console.log('Auth status:', authAgent.status); // "AUTHENTICATED"
}

// Step 6: Use the authenticated profile
const browser = await kernel.browsers.create({
  profile: { name: 'doordash-user-123' },
  stealth: true,
});

console.log('Browser ready:', browser.cdp_ws_url);
// Run your automation - the browser is already logged in!

// Clean up when done
await kernel.browsers.deleteByID(browser.session_id);
```

```python Python
from kernel import Kernel
import asyncio

kernel = Kernel()

# Step 1: Create or get existing Auth Agent
agent = await kernel.agents.auth.create(
    target_domain="doordash.com",
    profile_name="doordash-user-123",
    login_url="https://identity.doordash.com/auth",  # Optional
)

# Step 2: Start the auth flow
invocation = await kernel.agents.auth.invocations.create(
    auth_agent_id=agent.id,
)

# Step 3: Check if already logged in
if invocation.status == "ALREADY_AUTHENTICATED":
    print("Already authenticated! Profile is ready to use.")
else:
    print(f"Redirect user to: {invocation.hosted_url}")

# Step 4: Poll for completion
async def poll_for_completion(invocation_id: str):
    max_wait_seconds = 5 * 60
    start_time = asyncio.get_event_loop().time()

    while asyncio.get_event_loop().time() - start_time < max_wait_seconds:
        status = await kernel.agents.auth.invocations.retrieve(invocation_id)

        if status.status == "SUCCESS":
            return {"success": True}
        if status.status in ("EXPIRED", "CANCELED"):
            return {"success": False, "reason": status.status}

        await asyncio.sleep(2)

    return {"success": False, "reason": "TIMEOUT"}

result = await poll_for_completion(invocation.invocation_id)

# Step 5: Verify auth agent status
if result["success"]:
    auth_agent = await kernel.agents.auth.retrieve(agent.id)
    print(f"Auth status: {auth_agent.status}")

# Step 6: Use the authenticated profile
browser = await kernel.browsers.create(
    profile={"name": "doordash-user-123"},
    stealth=True,
)

print(f"Browser ready: {browser.cdp_ws_url}")

# Clean up when done
await kernel.browsers.delete_by_id(browser.session_id)
```
</CodeGroup>

## Notes

- For web applications, you may want to redirect users back to your app after authentication completes. Use the invocation's `hosted_url` as a starting point and implement polling patterns on your backend to check for when the Agent Auth completed.
