---
title: "Credentials"
description: "Securely store login credentials for automated re-authentication"
---

Credentials allow you to securely store login information that enables fully automated authentication flows. When linked to an Auth Agent, credentials enable automatic re-authentication when sessions expire—without any user interaction.

## Why Use Credentials?

Without stored credentials, every time a session expires, you need to redirect users back through the login flow. With credentials:

- **Automated re-auth** - Sessions can be refreshed automatically in the background
- **No user interaction** - Re-authentication happens without user involvement
- **Secure storage** - Credentials are encrypted at rest using per-organization keys
- **Never exposed** - Values are never returned in API responses

## How Credentials Work

<Steps>
  <Step title="Store Credentials">
    ```typescript
    const credential = await kernel.credentials.create({
      name: 'my-login',
      domain: 'example.com',
      values: { email: 'user@example.com', password: 'secret' },
    });
    ```
  </Step>
  <Step title="Link to Auth Agent">
    ```typescript
    const agent = await kernel.agents.auth.create({
      domain: 'example.com',
      profile_name: 'my-profile',
      credential_name: 'my-login',
    });
    ```
  </Step>
  <Step title="Complete Initial Login">
    Run one successful authentication to save form selectors (via [Auto-Login](/agent-auth/auto-login) or [Hosted UI](/agent-auth/hosted-ui)).
  </Step>
  <Step title="Automatic Re-auth">
    ```typescript
    // When session expires, trigger re-auth
    const reauth = await kernel.agents.auth.reauth(agent.id);
    ```
  </Step>
</Steps>

## Creating Credentials

Store credentials using the Credentials API. Values are encrypted immediately and cannot be retrieved.

<CodeGroup>
```typescript TypeScript
import Kernel from '@onkernel/sdk';

const kernel = new Kernel();

// Create a credential
const credential = await kernel.credentials.create({
  name: 'my-netflix-login',           // Unique name within your org
  domain: 'netflix.com',              // Target domain
  values: {                           // Key-value pairs of login fields
    email: 'user@example.com',
    password: 'secretpassword123',
  },
});

console.log('Credential created:', credential.id);
// Note: values are NOT returned - only metadata
```

```python Python
from kernel import Kernel

kernel = Kernel()

# Create a credential
credential = await kernel.credentials.create(
    name="my-netflix-login",
    domain="netflix.com",
    values={
        "email": "user@example.com",
        "password": "secretpassword123",
    },
)

print(f"Credential created: {credential.id}")
```
</CodeGroup>

**Parameters:**

| Parameter | Required | Description |
|-----------|----------|-------------|
| `name` | Yes | Unique name for the credential within your organization |
| `domain` | Yes | Target domain this credential is for (e.g., `netflix.com`) |
| `values` | Yes | Object containing field name → value pairs |
| `totp_secret` | No | Base32-encoded TOTP secret for automatic 2FA code generation |

<Warning>
Credential values are write-only. Once stored, they cannot be retrieved via the API. Only metadata (name, domain, created_at) is returned.
</Warning>

## Linking Credentials to Auth Agents

There are two ways to link credentials to an Auth Agent:

### Option 1: Link During Auth Agent Creation

```typescript
// Create auth agent with credential link
const agent = await kernel.agents.auth.create({
  domain: 'netflix.com',
  profile_name: 'my-profile',
  credential_id: credential.id,  // Link the credential
});
```

### Option 2: Save Credentials During Auth Flow

During an authentication invocation, you can save the entered credentials:

```typescript
const invocation = await kernel.agents.auth.invocations.create({
  auth_agent_id: agent.id,
  save_credential_as: 'my-netflix-login',  // Save credentials when login succeeds
});
```

This approach:
- Creates the credential automatically when login succeeds
- Links it to the Auth Agent
- Saves the form selectors for future re-auth

## Using Stored Credentials

Once credentials are linked and an initial login has completed (capturing form selectors), the Auth Agent can re-authenticate automatically.

### Checking Re-auth Capability

```typescript
const agent = await kernel.agents.auth.retrieve(agentId);

console.log('Status:', agent.status);           // AUTHENTICATED or NEEDS_AUTH
console.log('Can Reauth:', agent.can_reauth);   // true if credentials + selectors exist
console.log('Credential ID:', agent.credential_id);
console.log('Has Selectors:', agent.has_selectors);
```

An Auth Agent `can_reauth` when:
1. It has a linked credential (`credential_id` is set)
2. It has saved form selectors from a previous successful login (`has_selectors` is true)

### Triggering Re-authentication

When sessions expire, trigger re-authentication:

```typescript
const reauth = await kernel.agents.auth.reauth(agent.id);

switch (reauth.status) {
  case 'REAUTH_STARTED':
    console.log('Re-auth started, invocation:', reauth.invocation_id);
    // Poll for completion
    break;
  case 'ALREADY_AUTHENTICATED':
    console.log('Session is still valid');
    break;
  case 'CANNOT_REAUTH':
    console.log('Cannot re-auth:', reauth.message);
    // Missing credentials or selectors - need manual login
    break;
}
```

Poll for completion, then use [Session Monitoring](/agent-auth/session-monitoring) to detect future expirations.

## Managing Credentials

### List Credentials

```typescript
const credentials = await kernel.credentials.list({
  domain: 'netflix.com',  // Optional: filter by domain
});

for (const cred of credentials) {
  console.log(`${cred.name} (${cred.domain}) - Created: ${cred.created_at}`);
}
```

### Get Credential Details

```typescript
const credential = await kernel.credentials.retrieve(credentialId);

console.log('Name:', credential.name);
console.log('Domain:', credential.domain);
console.log('Created:', credential.created_at);
console.log('Updated:', credential.updated_at);
// Note: values are never returned
```

### Update Credentials

```typescript
await kernel.credentials.update(credentialId, {
  name: 'updated-name',  // Optional: update name
  values: {              // Optional: update values
    email: 'newemail@example.com',
    password: 'newpassword',
  },
});
```

### Delete Credentials

```typescript
await kernel.credentials.delete(credentialId);
```

<Warning>
Deleting a credential unlinks it from any associated Auth Agents. Those agents will no longer be able to re-authenticate automatically.
</Warning>

## Credential Values Schema

The `values` object is flexible—it stores whatever key-value pairs you provide. Common patterns:

### Basic Email/Password

```typescript
values: {
  email: 'user@example.com',
  password: 'secretpassword',
}
```

### Username/Password

```typescript
values: {
  username: 'myusername',
  password: 'secretpassword',
}
```

### With TOTP-based 2FA

For sites that use authenticator apps (Google Authenticator, Authy, 1Password, etc.) for two-factor authentication, you can provide the TOTP secret to enable fully automated login—including the 2FA step.

```typescript
const credential = await kernel.credentials.create({
  name: 'my-login',
  domain: 'example.com',
  values: {
    email: 'user@example.com',
    password: 'secretpassword',
  },
  totp_secret: 'JBSWY3DPEHPK3PXP',  // Base32-encoded TOTP secret
});
```

When the Auth Agent detects a 2FA code field during login, it automatically generates the current 6-digit code using the provided secret—no manual intervention required.

#### What is a TOTP Secret?

A TOTP (Time-based One-Time Password) secret is a base32-encoded key shared between you and the target site. It's the same secret your authenticator app uses to generate 6-digit codes that change every 30 seconds.

#### How to Obtain Your TOTP Secret

1. Go to the target site's security or 2FA settings
2. Choose "Set up authenticator app" (or re-setup if already configured)
3. Look for a link like "Can't scan the code?" or "Enter manually"
4. Copy the text secret shown (e.g., `JBSW Y3DP EHPK 3PXP`)
5. Remove any spaces and use it as the `totp_secret`

#### Completing 2FA Setup with Kernel

When setting up 2FA on a site, you typically need to enter a verification code to confirm the setup. When you store your TOTP secret in Kernel, we return the current code so you can complete setup immediately:

```typescript
// Create credential with TOTP secret
const credential = await kernel.credentials.create({
  name: 'my-login',
  domain: 'example.com',
  values: { email: 'user@example.com', password: 'secret' },
  totp_secret: 'JBSWY3DPEHPK3PXP',
});

// Use the returned code to complete 2FA setup on the site
console.log('Enter this code:', credential.totp_code);           // e.g., "847291"
console.log('Expires at:', credential.totp_code_expires_at);     // ISO 8601 timestamp
```

If you need a fresh code later (e.g., for manual login or the first code expired), use the TOTP code endpoint:

```typescript
const { code, expires_at } = await kernel.credentials.totpCode(credential.id);
console.log('Current code:', code);  // Fresh 6-digit code
```

This means you can store your TOTP secrets **only in Kernel**—no need to also add them to a personal authenticator app.

<Warning>
Store your TOTP secret securely. If you only configure the authenticator app by scanning the QR code, you may not have access to the text secret later.
</Warning>

#### Supported 2FA Types

| Type | Supported | Notes |
|------|-----------|-------|
| **TOTP (Authenticator apps)** | ✅ Yes | Google Authenticator, Authy, 1Password, etc. |
| **SMS OTP** | ❌ No | Requires receiving a text message |
| **Email OTP** | ❌ No | Requires checking email |
| **Push notifications** | ❌ No | Requires mobile app approval |
| **Hardware keys (FIDO/U2F)** | ❌ No | Requires physical device |

<Tip>
If `totp_secret` is not configured and the site requires 2FA, you'll be prompted to enter the code manually via the Hosted UI.
</Tip>

### Multiple Fields

Some sites have additional fields (company ID, account number, etc.):

```typescript
values: {
  company_id: 'ACME123',
  username: 'jsmith',
  password: 'secretpassword',
}
```

### Phone Number

For sites that require phone-based login:

```typescript
values: {
  phone: '+1234567890',
  password: 'secretpassword',
}
```

## Complete Example: Automated Auth Flow

Here's a complete example setting up fully automated authentication:

```typescript
import Kernel from '@onkernel/sdk';

const kernel = new Kernel();

async function setupAutomatedAuth() {
  // 1. Create credential (with optional TOTP secret for 2FA sites)
  const credential = await kernel.credentials.create({
    name: 'acme-portal-login',
    domain: 'portal.acme.com',
    values: {
      email: 'agent@company.com',
      password: 'secure-password-123',
    },
    // Optional: provide TOTP secret for fully automated 2FA
    totp_secret: 'JBSWY3DPEHPK3PXP',
  });

  // 2. Create auth agent with credential
  const agent = await kernel.agents.auth.create({
    domain: 'portal.acme.com',
    profile_name: 'acme-agent-profile',
    credential_id: credential.id,
    login_url: 'https://portal.acme.com/login',
  });

  // 3. Complete initial login to capture selectors
  const invocation = await kernel.agents.auth.invocations.create({
    auth_agent_id: agent.id,
  });

  console.log('Complete initial login at:', invocation.hosted_url);
  // User completes login once...

  // After initial login, agent.can_reauth will be true
}

async function useAuthenticatedBrowser(agentId: string) {
  // Check if re-auth is needed
  const agent = await kernel.agents.auth.retrieve(agentId);

  if (agent.status === 'NEEDS_AUTH') {
    if (agent.can_reauth) {
      // Automated re-auth
      const reauth = await kernel.agents.auth.reauth(agentId);
      if (reauth.status === 'REAUTH_STARTED') {
        // Wait for re-auth to complete
        await pollForCompletion(reauth.invocation_id);
      }
    } else {
      throw new Error('Cannot re-auth - manual login required');
    }
  }

  // Use the authenticated profile
  const browser = await kernel.browsers.create({
    profile: { name: agent.profile_name },
    stealth: true,
  });

  return browser;
}
```

## Security

Credentials are designed with security as the top priority:

| Security Feature | Description |
|-----------------|-------------|
| **Encryption at rest** | All credential values and TOTP secrets are encrypted using per-organization keys |
| **Write-only values** | Values and TOTP secrets cannot be retrieved via the API after creation |
| **Never logged** | Credential values and TOTP secrets are never written to logs |
| **Never exposed** | Values are injected directly into form fields, never returned in API responses |
| **Isolated execution** | Authentication runs in an isolated browser environment |
| **TOTP status only** | API only returns `has_totp_secret` (boolean), never the secret itself |
| **Ephemeral TOTP codes** | Generated codes expire every 30 seconds and are only returned when needed |

## Best Practices

1. **Use descriptive names** - Name credentials clearly (e.g., `production-crm-login`, `staging-portal-admin`)

2. **One credential per account** - Create separate credentials for different user accounts

3. **Monitor auth status** - Use [Session Monitoring](/agent-auth/session-monitoring) to detect when re-auth is needed

4. **Handle re-auth failures** - If automated re-auth fails (password changed, new 2FA method), fall back to manual login

## Next Steps

<CardGroup cols={2}>
  <Card title="Auto-Login" icon="bolt" href="/agent-auth/auto-login">
    Fully automated login with pre-linked credentials
  </Card>
  <Card title="Session Monitoring" icon="clock" href="/agent-auth/session-monitoring">
    Automatic session health checks and re-auth
  </Card>
</CardGroup>
