---
title: "Block Ads and Trackers with page.route()"
sidebarTitle: "Block Ads & Trackers"
description: "Speed up page loads by 50-70% by blocking ads, analytics, and tracking scripts with Playwright's network interception on Kernel browsers."
---

Block unnecessary resources to dramatically speed up page loads, reduce bandwidth, and avoid bot-detection scripts. Works perfectly with Kernel's CDP support.

## What This Recipe Does

1. Intercept all network requests with `page.route()`
2. Block ads, analytics, fonts, and images
3. Only load essential resources (HTML, JS, data)
4. Speed up automation by 50-70%

## Use Cases

- Faster web scraping
- Reduced bandwidth costs
- Avoid ad-blocker detection (ironically)
- Focus on text/data extraction
- Speed up E2E tests
- Bypass slow third-party scripts

## Complete Code

<CodeGroup>
```typescript TypeScript
import { chromium } from 'playwright-core';
import { Kernel } from '@onkernel/sdk';

// Common ad/tracker domains
const BLOCKED_DOMAINS = [
  'googletagmanager.com',
  'google-analytics.com',
  'doubleclick.net',
  'facebook.net',
  'facebook.com/tr',
  'connect.facebook.net',
  'analytics.twitter.com',
  'static.ads-twitter.com',
  'amazon-adsystem.com',
  'googlesyndication.com',
  'adservice.google.com',
  'quantserve.com',
  'scorecardresearch.com',
  'hotjar.com',
  'mouseflow.com',
  'clarity.ms',
  'fullstory.com'
];

// Resource types to block
const BLOCKED_TYPES = ['image', 'font', 'stylesheet', 'media'];

export async function scrapeWithoutAds(url: string) {
  const kernel = new Kernel({ apiKey: process.env.KERNEL_API_KEY! });
  const kb = await kernel.browsers.create({ headless: true });
  
  const browser = await chromium.connectOverCDP({
    wsEndpoint: kb.cdp_ws_url
  });
  
  const page = browser.contexts()[0].pages()[0];
  
  // Block resources
  await page.route('**/*', route => {
    const request = route.request();
    const url = request.url();
    const type = request.resourceType();
    
    // Block by domain
    if (BLOCKED_DOMAINS.some(domain => url.includes(domain))) {
      console.log(`Blocked tracker: ${url}`);
      return route.abort();
    }
    
    // Block by resource type
    if (BLOCKED_TYPES.includes(type)) {
      return route.abort();
    }
    
    // Allow everything else
    return route.continue();
  });
  
  // Navigate (much faster now)
  const startTime = Date.now();
  await page.goto(url, { waitUntil: 'domcontentloaded' });
  const loadTime = Date.now() - startTime;
  
  // Extract content
  const title = await page.title();
  const content = await page.evaluate(() => {
    const article = document.querySelector('article') || document.body;
    return article.innerText;
  });
  
  await browser.close();
  await kernel.browsers.deleteByID(kb.session_id);
  
  return {
    url,
    title,
    content,
    loadTimeMs: loadTime,
    message: `Loaded ${loadTime}ms (typically 50-70% faster)`
  };
}

// Usage
const result = await scrapeWithoutAds('https://example.com/article');
console.log(result);
```

```python Python
from playwright.async_api import async_playwright
from kernel import Kernel
import time

# Common ad/tracker domains
BLOCKED_DOMAINS = [
    'googletagmanager.com',
    'google-analytics.com',
    'doubleclick.net',
    'facebook.net',
    'facebook.com/tr',
    'connect.facebook.net',
    'analytics.twitter.com',
    'static.ads-twitter.com',
    'amazon-adsystem.com',
    'googlesyndication.com',
    'adservice.google.com',
    'quantserve.com',
    'scorecardresearch.com',
    'hotjar.com',
    'mouseflow.com',
    'clarity.ms',
    'fullstory.com'
]

BLOCKED_TYPES = ['image', 'font', 'stylesheet', 'media']

async def scrape_without_ads(url: str):
    kernel = Kernel()
    kb = kernel.browsers.create(headless=True)
    
    async with async_playwright() as p:
        browser = await p.chromium.connect_over_cdp(kb.cdp_ws_url)
        page = browser.contexts[0].pages[0]
        
        # Block resources
        async def handle_route(route):
            request = route.request
            req_url = request.url
            req_type = request.resource_type
            
            # Block by domain
            if any(domain in req_url for domain in BLOCKED_DOMAINS):
                print(f'Blocked tracker: {req_url}')
                await route.abort()
                return
            
            # Block by type
            if req_type in BLOCKED_TYPES:
                await route.abort()
                return
            
            # Allow everything else
            await route.continue_()
        
        await page.route('**/*', handle_route)
        
        # Navigate (much faster now)
        start_time = time.time()
        await page.goto(url, wait_until='domcontentloaded')
        load_time = (time.time() - start_time) * 1000
        
        # Extract content
        title = await page.title()
        content = await page.evaluate('''() => {
            const article = document.querySelector('article') || document.body;
            return article.innerText;
        }''')
        
        await browser.close()
        kernel.browsers.delete_by_id(kb.session_id)
    
    return {
        'url': url,
        'title': title,
        'content': content,
        'load_time_ms': load_time,
        'message': f'Loaded {load_time:.0f}ms (typically 50-70% faster)'
    }

# Usage
result = await scrape_without_ads('https://example.com/article')
print(result)
```
</CodeGroup>

## Environment Variables

```bash
KERNEL_API_KEY=your_kernel_api_key
```

## Expected Output

```json
{
  "url": "https://example.com/article",
  "title": "Article Title",
  "content": "Article text content...",
  "loadTimeMs": 1200,
  "message": "Loaded 1200ms (typically 50-70% faster)"
}
```

Without blocking: ~4000ms
With blocking: ~1200ms
**Speedup: 70%**

## Advanced Patterns

### Block Everything Except Specific Domains

```typescript
const ALLOWED_DOMAINS = ['example.com', 'cdn.example.com'];

await page.route('**/*', route => {
  const url = new URL(route.request().url());
  
  // Allow only specific domains
  if (ALLOWED_DOMAINS.some(domain => url.hostname.includes(domain))) {
    return route.continue();
  }
  
  // Block everything else
  return route.abort();
});
```

### Smart Blocking (Keep Some Images)

```typescript
await page.route('**/*', route => {
  const request = route.request();
  const url = request.url();
  const type = request.resourceType();
  
  // Keep product images, block others
  if (type === 'image') {
    if (url.includes('/products/') || url.includes('/images/')) {
      return route.continue();
    }
    return route.abort();
  }
  
  // Block trackers
  if (BLOCKED_DOMAINS.some(d => url.includes(d))) {
    return route.abort();
  }
  
  return route.continue();
});
```

### Count Blocked Requests

```typescript
let blockedCount = 0;
const blockedUrls: string[] = [];

await page.route('**/*', route => {
  const url = route.request().url();
  
  if (BLOCKED_DOMAINS.some(d => url.includes(d))) {
    blockedCount++;
    blockedUrls.push(url);
    return route.abort();
  }
  
  return route.continue();
});

await page.goto(url);

console.log(`Blocked ${blockedCount} requests`);
console.log('Blocked URLs:', blockedUrls);
```

### Block by File Size

```typescript
await page.route('**/*', async route => {
  // Fetch to check size
  const response = await route.fetch();
  const contentLength = parseInt(
    response.headers()['content-length'] || '0'
  );
  
  // Block files >500KB
  if (contentLength > 500 * 1024) {
    console.log(`Blocked large file: ${route.request().url()} (${contentLength} bytes)`);
    return route.abort();
  }
  
  // Fulfill with the fetched response
  return route.fulfill({ response });
});
```

## Performance Comparison

### Before (No Blocking)

```
Total requests: 150
- HTML/JS/CSS: 20 (essential)
- Images: 50
- Fonts: 10
- Analytics/Ads: 70
Total load time: 4.2 seconds
```

### After (With Blocking)

```
Total requests: 20
- HTML/JS/CSS: 20 (essential)
- Images: 0 (blocked)
- Fonts: 0 (blocked)
- Analytics/Ads: 0 (blocked)
Total load time: 1.3 seconds
Speedup: 69%
```

## Common Patterns by Use Case

### News Articles (Text Only)

```typescript
const BLOCKED_TYPES = ['image', 'font', 'stylesheet', 'media', 'websocket'];
const BLOCKED_DOMAINS = [
  ...BLOCKED_DOMAINS, // from above
  'taboola.com',
  'outbrain.com',
  'disqus.com'
];
```

### E-Commerce (Keep Product Images)

```typescript
await page.route('**/*', route => {
  const url = route.request().url();
  const type = route.request().resourceType();
  
  // Keep product images
  if (type === 'image' && url.includes('/product')) {
    return route.continue();
  }
  
  // Block other images
  if (type === 'image') {
    return route.abort();
  }
  
  // Block trackers
  if (BLOCKED_DOMAINS.some(d => url.includes(d))) {
    return route.abort();
  }
  
  return route.continue();
});
```

### API Scraping (Block Everything Visual)

```typescript
await page.route('**/*', route => {
  const type = route.request().resourceType();
  
  // Allow only document, xhr, fetch
  if (['document', 'xhr', 'fetch'].includes(type)) {
    return route.continue();
  }
  
  // Block everything else
  return route.abort();
});
```

## Combine with Stealth Mode

For maximum speed and stealth:

```typescript
const kb = await kernel.browsers.create({
  headless: true,
  stealth: true // Adds proxies + CAPTCHA solver
});

// Then add resource blocking
await page.route('**/*', route => {
  // ... blocking logic ...
});
```

This combines:
- Proxy rotation (stealth mode)
- CAPTCHA solving (stealth mode)
- Resource blocking (your code)

Result: Fast, undetectable scraping.

## Troubleshooting

### Page Won't Load

If the page appears blank or broken:

1. Check if you blocked too much:
```typescript
// Debug: log what you're blocking
await page.route('**/*', route => {
  if (shouldBlock(route)) {
    console.log('Blocking:', route.request().url());
    return route.abort();
  }
  return route.continue();
});
```

2. Allow essential resources:
```typescript
// Don't block document and scripts
if (['document', 'script', 'xhr', 'fetch'].includes(type)) {
  return route.continue();
}
```

### Content Missing

If extracted content is incomplete:

1. Some sites load content via JS that needs stylesheets
2. Try less aggressive blocking:
```typescript
// Block only trackers, keep images/fonts
const BLOCKED_TYPES = []; // empty
```

### Still Slow

If blocking doesn't help:

1. The site might have slow server
2. Try `waitUntil: 'domcontentloaded'` instead of `'networkidle'`
3. Use headless mode (faster than headful)

## Cost Savings

**Bandwidth:**
- Before: 5MB per page × 1,000 pages = 5GB
- After: 500KB per page × 1,000 pages = 500MB
- **Savings: 90% bandwidth**

**Time:**
- Before: 4s per page × 1,000 pages = 67 minutes
- After: 1.5s per page × 1,000 pages = 25 minutes
- **Savings: 63% time** = 63% cost on Kernel

## Related Recipes

- [Screenshot + DOM + LLM](/recipes/screenshot-dom-llm) - Extract content with AI
- [Network Interception](/troubleshooting/network-interception) - Full guide
- [Parallel Browsers](/recipes/parallel-browsers) - Process faster

## Related Features

- [Stealth Mode](/browsers/stealth) - Avoid detection
- [Headless Mode](/browsers/headless) - Faster execution
- [Network Interception](/troubleshooting/network-interception)

## Support

Questions about resource blocking? Join our [Discord](https://discord.gg/FBrveQRcud).

