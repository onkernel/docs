---
title: "Auto-Login"
description: "Fully automated authentication with pre-linked credentials"
---

Auto-Login is the simplest approach for automated flows—pre-create credentials, link them to the auth agent, and the system handles everything automatically. Just poll for completion.

## When to Use Auto-Login

Use Auto-Login when:
- You already have the user's credentials (from your secrets manager, user input collected earlier, etc.)
- You want fully automated login with minimal code
- You're building headless/bot workflows that don't require user interaction

<Tip>
If you need users to enter their own credentials, use the [Hosted UI](/agents/auth/hosted-ui) or [Programmatic](/agents/auth/programmatic) flows instead.
</Tip>

## How It Works

<Steps>
  <Step title="Create a Credential">
    ```typescript
    const credential = await kernel.credentials.create({
      name: 'user-123-netflix',
      domain: 'netflix.com',
      values: { username: 'user@example.com', password: 'secretpassword' },
    });
    ```
  </Step>
  <Step title="Create Auth Agent with Credential Linked">
    ```typescript
    const agent = await kernel.agents.auth.create({
      domain: 'netflix.com',
      profile_name: 'netflix-user-123',
      credential_name: credential.name,
    });
    ```
  </Step>
  <Step title="Start an Invocation">
    ```typescript
    const invocation = await kernel.agents.auth.invocations.create({
      auth_agent_id: agent.id,
    });
    // System automatically discovers fields, maps credentials, and submits
    ```
  </Step>
  <Step title="Poll for Completion">
    ```typescript
    const state = await kernel.agents.auth.invocations.retrieve(invocation.invocation_id);
    // Poll until state.status === 'SUCCESS'
    ```
  </Step>
  <Step title="Use the Authenticated Profile">
    ```typescript
    const browser = await kernel.browsers.create({
      profile: { name: 'netflix-user-123' },
      stealth: true,
    });
    ```
  </Step>
</Steps>

## Complete Example

<CodeGroup>
```typescript TypeScript
import Kernel from '@onkernel/sdk';

const kernel = new Kernel();

// Step 1: Create credential with login values
const credential = await kernel.credentials.create({
  name: 'user-123-netflix',
  domain: 'netflix.com',
  values: {
    username: 'user@example.com',
    password: 'secretpassword',
  },
});

// Step 2: Create auth agent with credential linked
const agent = await kernel.agents.auth.create({
  domain: 'netflix.com',
  profile_name: 'netflix-user-123',
  credential_name: credential.name,
  login_url: 'https://netflix.com/login', // Optional: speeds up discovery
});

// Step 3: Start invocation - auto-login kicks in automatically
const invocation = await kernel.agents.auth.invocations.create({
  auth_agent_id: agent.id,
});

// Step 4: Poll for completion
const result = await pollForCompletion(invocation.invocation_id);

// If already authenticated, status will immediately be SUCCESS
if (result.success) {
  console.log('Auto-login successful!');
}

// Step 5: Use the profile
const browser = await kernel.browsers.create({
  profile: { name: 'netflix-user-123' },
  stealth: true,
});

// Run your automation...
await kernel.browsers.deleteByID(browser.session_id);
```

```python Python
from kernel import Kernel
import asyncio

kernel = Kernel()

# Step 1: Create credential with login values
credential = await kernel.credentials.create(
    name="user-123-netflix",
    domain="netflix.com",
    values={
        "username": "user@example.com",
        "password": "secretpassword",
    },
)

# Step 2: Create auth agent with credential linked
agent = await kernel.agents.auth.create(
    domain="netflix.com",
    profile_name="netflix-user-123",
    credential_name=credential.name,
    login_url="https://netflix.com/login",  # Optional: speeds up discovery
)

# Step 3: Start invocation - auto-login kicks in automatically
invocation = await kernel.agents.auth.invocations.create(
    auth_agent_id=agent.id,
)

# Step 4: Poll for completion
result = await poll_for_completion(invocation.invocation_id)

# If already authenticated, status will immediately be SUCCESS
if result["success"]:
    print("Auto-login successful!")

# Step 5: Use the profile
browser = await kernel.browsers.create(
    profile={"name": "netflix-user-123"},
    stealth=True,
)

# Run your automation...
await kernel.browsers.delete_by_id(browser.session_id)
```
</CodeGroup>

## Polling for Completion

Auto-login runs asynchronously. Poll the invocation status to know when it completes:

<CodeGroup>
```typescript TypeScript
async function pollForCompletion(invocationId: string) {
  const maxWaitMs = 5 * 60 * 1000; // 5 minutes
  const start = Date.now();
  let delay = 3000;

  while (Date.now() - start < maxWaitMs) {
    const state = await kernel.agents.auth.invocations.retrieve(invocationId);

    console.log(`Status: ${state.status}, Step: ${state.step}`);

    if (state.status === 'SUCCESS') {
      return { success: true, state };
    }
    if (state.status === 'FAILED') {
      return { success: false, reason: 'FAILED', error: state.error_message };
    }
    if (state.status === 'EXPIRED' || state.status === 'CANCELED') {
      return { success: false, reason: state.status };
    }

    // Check if manual input needed (e.g., MFA code not in credentials)
    if (state.step === 'awaiting_input') {
      return { success: false, reason: 'MANUAL_INPUT_REQUIRED', state };
    }

    await new Promise(r => setTimeout(r, delay));
    delay = Math.min(delay * 1.5, 5000);
  }

  return { success: false, reason: 'TIMEOUT' };
}
```

```python Python
async def poll_for_completion(invocation_id: str):
    max_wait_seconds = 5 * 60
    start_time = asyncio.get_event_loop().time()
    delay = 3

    while asyncio.get_event_loop().time() - start_time < max_wait_seconds:
        state = await kernel.agents.auth.invocations.retrieve(invocation_id)

        print(f"Status: {state.status}, Step: {state.step}")

        if state.status == "SUCCESS":
            return {"success": True, "state": state}
        if state.status == "FAILED":
            return {"success": False, "reason": "FAILED", "error": state.error_message}
        if state.status in ("EXPIRED", "CANCELED"):
            return {"success": False, "reason": state.status}

        # Check if manual input needed (e.g., MFA code not in credentials)
        if state.step == "awaiting_input":
            return {"success": False, "reason": "MANUAL_INPUT_REQUIRED", "state": state}

        await asyncio.sleep(delay)
        delay = min(delay * 1.5, 5)

    return {"success": False, "reason": "TIMEOUT"}
```
</CodeGroup>

**Invocation step values** (useful for monitoring progress):

| Step | Description |
|------|-------------|
| `initialized` | Invocation just started |
| `discovering` | Currently discovering login fields |
| `awaiting_input` | Waiting for input (manual intervention needed) |
| `submitting` | Currently submitting credentials |
| `awaiting_external_action` | Waiting for external action (push notification, security key) |
| `completed` | Login flow finished |
| `expired` | Invocation expired before completion |

## Credential Field Mapping

Auto-login maps your credential values to discovered form fields:

1. **Direct name match** - If your credential has `username` and the form has a field named `username`, they match
2. **Type-based fallback** - If no name match, maps by field type:
   - `email` type → uses `email` or `username` from credentials
   - `password` type → uses `password` from credentials
   - `tel` type → uses `phone` from credentials
   - `text` type → uses `username` or `email` as fallback

**Recommended credential structure:**

```typescript
{
  values: {
    username: 'user@example.com',  // Works for email and text fields
    password: 'secretpassword',
    phone: '+1234567890',           // Optional, for sites that need it
  },
  totp_secret: 'JBSWY3DPEHPK3PXP', // Optional, for 2FA sites
}
```

## Multi-Step Form Handling

Auto-login automatically handles multi-step login forms:

- **Step 1**: Discovers username/email field → maps and submits
- **Step 2**: New password field appears → maps and submits
- **Step 3**: 2FA code field appears → maps if `code` is in credentials, otherwise pauses

If the system encounters fields it can't satisfy from your credentials (like a TOTP field without a `totp_secret`), it sets `step: 'awaiting_input'` and pauses.

### Handling Paused Flows

When auto-login pauses, check `pending_fields` and submit the missing values:

<CodeGroup>
```typescript TypeScript
while (state.status === 'IN_PROGRESS') {
  state = await kernel.agents.auth.invocations.retrieve(invocation.invocation_id);

  if (state.step === 'awaiting_input' && state.pending_fields?.length) {
    // Build values for the pending fields
    const fieldValues: Record<string, string> = {};
    for (const field of state.pending_fields) {
      fieldValues[field.name] = await getValueFromUser(field);
    }

    await kernel.agents.auth.invocations.submit(invocation.invocation_id, {
      field_values: fieldValues,
    });
  }

  await sleep(2000);
}
```

```python Python
while state.status == "IN_PROGRESS":
    state = await kernel.agents.auth.invocations.retrieve(invocation.invocation_id)

    if state.step == "awaiting_input" and len(state.pending_fields or []):
        # Build values for the pending fields
        field_values = {}
        for field in state.pending_fields:
            field_values[field.name] = await get_value_from_user(field)

        await kernel.agents.auth.invocations.submit(
            invocation.invocation_id,
            field_values=field_values,
        )

    await asyncio.sleep(2)
```
</CodeGroup>

<Warning>
**2FA handling:** For TOTP-based 2FA, include a `totp_secret` on your credential to enable fully automated code generation. For SMS or email OTP, the flow will pause at `step: 'awaiting_input'` with the OTP field in `pending_fields`, allowing the user to enter the code via your UI.
</Warning>

## SSO Auto-Login

For sites that support "Sign in with Google/GitHub/Microsoft" buttons, you can automate the entire OAuth flow using the `sso_provider` field on credentials.

### How SSO Auto-Login Works

1. Create a credential with `sso_provider` set to the provider name (e.g., `google`)
2. The credential `values` should contain the IdP's login fields (email/password for the Google account)
3. Create an auth agent with `allowed_domains` including the IdP domain
4. Start an invocation—the workflow automatically clicks the SSO button and completes the OAuth flow

### SSO Example

<CodeGroup>
```typescript TypeScript
import Kernel from '@onkernel/sdk';

const kernel = new Kernel();

// 1. Create credential for GitHub SSO
const credential = await kernel.credentials.create({
  name: 'my-github-sso',
  domain: 'example.com',  // The site you're logging into
  values: {
    username: 'github-username',
    password: 'github-password',
  },
  sso_provider: 'github',  // Clicks "Continue with GitHub" button
});

// 2. Create auth agent with GitHub in allowed_domains
const agent = await kernel.agents.auth.create({
  domain: 'example.com',
  profile_name: 'my-profile',
  credential_name: credential.name,
  allowed_domains: ['github.com'],  // Required for GitHub SSO
});

// 3. Start invocation - fully automated
const invocation = await kernel.agents.auth.invocations.create({
  auth_agent_id: agent.id,
});

// 4. Poll for completion
const result = await pollForCompletion(invocation.invocation_id);
```

```python Python
from kernel import Kernel

kernel = Kernel()

# 1. Create credential for GitHub SSO
credential = await kernel.credentials.create(
    name="my-github-sso",
    domain="example.com",
    values={
        "username": "github-username",
        "password": "github-password",
    },
    sso_provider="github",
)

# 2. Create auth agent with GitHub in allowed_domains
agent = await kernel.agents.auth.create(
    domain="example.com",
    profile_name="my-profile",
    credential_name=credential.name,
    allowed_domains=["github.com"],
)

# 3. Start invocation - fully automated
invocation = await kernel.agents.auth.invocations.create(
    auth_agent_id=agent.id,
)

# 4. Poll for completion
result = await poll_for_completion(invocation.invocation_id)
```
</CodeGroup>

<Note>
The `sso_provider` value should match the provider name in the SSO button (e.g., `google`, `github`, `microsoft`, `okta`). The matching is case-insensitive.
</Note>

### allowed_domains Requirement

When using SSO, the login redirects to a different domain (e.g., `accounts.google.com`). You must include this domain in `allowed_domains` on the auth agent:

| SSO Provider | Required allowed_domains |
|--------------|--------------------------|
| Google | `accounts.google.com`, `google.com` |
| GitHub | `github.com` |
| Microsoft | `login.microsoftonline.com`, `microsoft.com` |

## Handling External Actions

Some login flows require external user action—like approving a push notification or inserting a security key. When this happens, the step becomes `awaiting_external_action` and `external_action_message` contains instructions for the user.

<CodeGroup>
```typescript TypeScript
while (state.status === 'IN_PROGRESS') {
  state = await kernel.agents.auth.invocations.retrieve(invocation.invocation_id);
  
  if (state.step === 'awaiting_external_action') {
    // Display message to user (e.g., "Tap 'Yes' on the Google prompt on your phone")
    console.log('Action required:', state.external_action_message);
    // Keep polling - user completes action externally
  }
  
  await sleep(2000);
}
```

```python Python
while state.status == "IN_PROGRESS":
    state = await kernel.agents.auth.invocations.retrieve(invocation.invocation_id)
    
    if state.step == "awaiting_external_action":
        # Display message to user
        print(f"Action required: {state.external_action_message}")
        # Keep polling - user completes action externally
    
    await asyncio.sleep(2)
```
</CodeGroup>

Common external action scenarios:
- **Google push notification** - "Tap 'Yes' on the Google prompt on your phone"
- **Security key** - "Insert your security key and tap the button"
- **Authenticator app approval** - "Approve the login request in your authenticator app"

<Tip>
For fully automated flows, prefer TOTP-based 2FA (with `totp_secret`) over push notifications or security keys, as these require no user interaction.
</Tip>

## Using Proxies

If the target site requires a specific IP or region, configure a proxy on the Auth Agent using `proxy: { proxy_id: 'your_proxy_id' }`. Use the same proxy when creating browsers afterward.

See [Proxies](/proxies/overview) for setup details.

<Warning>
Use the same proxy configuration for both the Auth Agent and subsequent browser sessions. Different IPs may trigger security measures on the target site.
</Warning>

## Next Steps

<CardGroup cols={2}>
  <Card title="Credentials" icon="key" href="/agents/auth/credentials">
    Store and manage login credentials
  </Card>
  <Card title="Session Monitoring" icon="clock" href="/agents/auth/session-monitoring">
    Automatic session health checks and re-auth
  </Card>
</CardGroup>
