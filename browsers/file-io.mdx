---
title: "File I/O"
description: "Downloads, uploads, and manipulating the browser's filesystem"
---

## Downloads

Kernel browsers run in fully sandboxed environments with writable filesystems. When your automation downloads a file, it's saved inside the browser's filesystem and can be retrieved using Kernel's File I/O APIs.


### Playwright

Playwright performs downloads via the browser itself, so there are a few steps:

- Create a browser session
- Configure browser download behavior using CDP
- Perform the download
- Retrieve the file from the browser's filesystem

<Note>
  With `behavior: 'default'`, downloads are saved to the browser's default download directory at `~/Downloads`. Use Kernel's File I/O APIs to retrieve files from this location.
</Note>

<Info>
  The CDP `downloadProgress` event signals when the browser finishes writing a
  file, but there may be a brief delay before the file becomes available through
  Kernel's File I/O APIs. This is especially true for larger downloads. We
  recommend polling `listFiles` to confirm the file exists before attempting to
  read it.
</Info>

<CodeGroup>
```typescript Typescript/Javascript
import Kernel from '@onkernel/sdk';
import { chromium } from 'playwright';
import fs from 'fs';
import os from 'os';
import pTimeout from 'p-timeout';

const DOWNLOAD_DIR = `${os.homedir()}/Downloads`;
const kernel = new Kernel();

// Poll listFiles until the expected file appears in the directory
async function waitForFile(
  sessionId: string,
  dir: string,
  filename: string,
  timeoutMs = 30_000
) {
  const start = Date.now();
  while (Date.now() - start < timeoutMs) {
    const files = await kernel.browsers.fs.listFiles(sessionId, { path: dir });
    if (files.some((f) => f.name === filename)) {
      return;
    }
    await new Promise((r) => setTimeout(r, 500));
  }
  throw new Error(`File ${filename} not found after ${timeoutMs}ms`);
}

async function main() {
  const kernelBrowser = await kernel.browsers.create();
  console.log('live view:', kernelBrowser.browser_live_view_url);

  const browser = await chromium.connectOverCDP(kernelBrowser.cdp_ws_url);
  const context = browser.contexts()[0] || (await browser.newContext());
  const page = context.pages()[0] || (await context.newPage());

  const client = await context.newCDPSession(page);
  await client.send('Browser.setDownloadBehavior', {
    behavior: 'default',
    eventsEnabled: true,
  });

  // Set up CDP listeners to capture download filename and completion
  let downloadFilename: string | undefined;
  let downloadState: string | undefined;
  let downloadCompletedResolve!: () => void;
  const downloadCompleted = new Promise<void>((resolve) => {
    downloadCompletedResolve = resolve;
  });

  client.on('Browser.downloadWillBegin', (event) => {
    downloadFilename = event.suggestedFilename ?? 'unknown';
    console.log('Download started:', downloadFilename);
  });

  client.on('Browser.downloadProgress', (event) => {
    if (event.state === 'completed' || event.state === 'canceled') {
      downloadState = event.state;
      downloadCompletedResolve();
    }
  });

  console.log('Navigating to download test page');
  await page.goto('https://browser-tests-alpha.vercel.app/api/download-test');
  await page.getByRole('link', { name: 'Download File' }).click();

  try {
    await pTimeout(downloadCompleted, {
      milliseconds: 10_000,
      message: new Error('Download timed out after 10 seconds'),
    });
    console.log('Download completed');
  } catch (err) {
    console.error(err);
    throw err;
  }

  if (!downloadFilename) {
    throw new Error('Unable to determine download filename');
  }

  if (downloadState === 'canceled') {
    throw new Error('Download was canceled');
  }

  // Wait for the file to be available via Kernel's File I/O APIs
  console.log(`Waiting for file: ${downloadFilename}`);
  await waitForFile(kernelBrowser.session_id, DOWNLOAD_DIR, downloadFilename);

  const remotePath = `${DOWNLOAD_DIR}/${downloadFilename}`;
  console.log(`Reading file: ${remotePath}`);

  const resp = await kernel.browsers.fs.readFile(kernelBrowser.session_id, {
    path: remotePath,
  });

  const bytes = await resp.bytes();
  fs.mkdirSync('downloads', { recursive: true });
  const localPath = `downloads/${downloadFilename}`;
  fs.writeFileSync(localPath, bytes);
  console.log(`Saved to ${localPath}`);

  await kernel.browsers.deleteByID(kernelBrowser.session_id);
  console.log('Kernel browser deleted successfully.');
}

main();

````

```python Python
import asyncio
import os
from pathlib import Path
import time
from kernel import Kernel
from playwright.async_api import async_playwright

DOWNLOAD_DIR = str(Path.home() / "Downloads")
kernel = Kernel()


# Poll list_files until the expected file appears in the directory
async def wait_for_file(
    session_id: str, dir: str, filename: str, timeout_sec: float = 30
):
    start = time.time()
    while time.time() - start < timeout_sec:
        files = kernel.browsers.fs.list_files(session_id, path=dir)
        if any(f.name == filename for f in files):
            return
        await asyncio.sleep(0.5)
    raise TimeoutError(f"File {filename} not found after {timeout_sec}s")


async def main():
    kernel_browser = kernel.browsers.create()
    print("Kernel browser live view url:", kernel_browser.browser_live_view_url)

    async with async_playwright() as playwright:
        browser = await playwright.chromium.connect_over_cdp(kernel_browser.cdp_ws_url)
        context = browser.contexts[0]
        page = context.pages[0] if len(context.pages) > 0 else await context.new_page()

        cdp_session = await context.new_cdp_session(page)
        await cdp_session.send(
            "Browser.setDownloadBehavior",
            {
                "behavior": "default",
                "eventsEnabled": True,
            },
        )

        download_completed = asyncio.Event()
        download_filename: str | None = None
        download_state: str | None = None

        def _on_download_begin(event):
            nonlocal download_filename
            download_filename = event.get("suggestedFilename", "unknown")
            print(f"Download started: {download_filename}")

        def _on_download_progress(event):
            nonlocal download_state
            if event.get("state") in ["completed", "canceled"]:
                download_state = event.get("state")
                download_completed.set()

        cdp_session.on("Browser.downloadWillBegin", _on_download_begin)
        cdp_session.on("Browser.downloadProgress", _on_download_progress)

        print("Navigating to download test page")
        await page.goto("https://browser-tests-alpha.vercel.app/api/download-test")
        await page.get_by_role("link", name="Download File").click()

        try:
            await asyncio.wait_for(download_completed.wait(), timeout=10)
            print("Download completed")
        except asyncio.TimeoutError:
            print("Download timed out after 10 seconds")
            raise

        if download_state == "canceled":
            raise RuntimeError("Download was canceled")

        # Wait for the file to be available via Kernel's File I/O APIs
        print(f"Waiting for file: {download_filename}")
        await wait_for_file(kernel_browser.session_id, DOWNLOAD_DIR, download_filename)

        resp = kernel.browsers.fs.read_file(
            kernel_browser.session_id, path=f"{DOWNLOAD_DIR}/{download_filename}"
        )
        local_path = f"./downloads/{download_filename}"
        os.makedirs("./downloads", exist_ok=True)
        resp.write_to_file(local_path)
        print(f"Saved to {local_path}")

        kernel.browsers.delete_by_id(kernel_browser.session_id)
        print("Kernel browser deleted successfully.")


if __name__ == "__main__":
    asyncio.run(main())
````

</CodeGroup>

<Info>We recommend using the [list files](/api-reference/browsers/list-files-in-a-directory) API to poll for file availability before calling [read file](/api-reference/browsers/read-file-contents), as shown in the examples above. This approach ensures reliable downloads, especially for larger files. You can also use `listFiles` to enumerate and save all downloads at the end of a session.</Info>

### Stagehand v3

When using Stagehand with Kernel browsers, you need to configure the download behavior in the `localBrowserLaunchOptions`:

```typescript
const stagehand = new Stagehand({
  env: "LOCAL",
  verbose: 1,
  localBrowserLaunchOptions: {
    cdpUrl: kernelBrowser.cdp_ws_url,
    downloadsPath: DOWNLOAD_DIR, // Specify where downloads should be saved
    acceptDownloads: true, // Enable downloads
  },
});
```

Here's a complete example:

```typescript
import { Stagehand } from "@browserbasehq/stagehand";
import Kernel from "@onkernel/sdk";
import fs from "fs";

const DOWNLOAD_DIR = "/tmp/downloads";

// Poll listFiles until any file appears in the directory
async function waitForFile(
    kernel: Kernel,
    sessionId: string,
    dir: string,
    timeoutMs = 30_000
) {
    const start = Date.now();
    while (Date.now() - start < timeoutMs) {
        const files = await kernel.browsers.fs.listFiles(sessionId, { path: dir });
        if (files.length > 0) {
            return files[0];
        }
        await new Promise((r) => setTimeout(r, 500));
    }
    throw new Error(`No files found in ${dir} after ${timeoutMs}ms`);
}

async function main() {
    const kernel = new Kernel();

    console.log("Creating browser via Kernel...");
    const kernelBrowser = await kernel.browsers.create({
        stealth: true,
    });

    console.log(`Kernel Browser Session Started`);
    console.log(`Session ID: ${kernelBrowser.session_id}`);
    console.log(`Watch live: ${kernelBrowser.browser_live_view_url}`);

    // Initialize Stagehand with Kernel's CDP URL and download configuration
    const stagehand = new Stagehand({
        env: "LOCAL",
        verbose: 1,
        localBrowserLaunchOptions: {
            cdpUrl: kernelBrowser.cdp_ws_url,
            downloadsPath: DOWNLOAD_DIR,
            acceptDownloads: true,
        },
    });

    await stagehand.init();

    const page = stagehand.context.pages()[0];

    await page.goto("https://browser-tests-alpha.vercel.app/api/download-test");

    // Use Stagehand to click the download button
    await stagehand.act("Click the download file link");
    console.log("Download triggered");

    // Wait for the file to be fully available via Kernel's File I/O APIs
    console.log("Waiting for file to appear...");
    const downloadedFile = await waitForFile(
        kernel,
        kernelBrowser.session_id,
        DOWNLOAD_DIR
    );
    console.log(`File found: ${downloadedFile.name}`);

    const remotePath = `${DOWNLOAD_DIR}/${downloadedFile.name}`;
    console.log(`Reading file from: ${remotePath}`);

    // Read the file from Kernel browser's filesystem
    const resp = await kernel.browsers.fs.readFile(kernelBrowser.session_id, {
        path: remotePath,
    });

    // Save to local filesystem
    const bytes = await resp.bytes();
    fs.mkdirSync("downloads", { recursive: true });
    const localPath = `downloads/${downloadedFile.name}`;
    fs.writeFileSync(localPath, bytes);
    console.log(`Saved to ${localPath}`);

    // Clean up
    await stagehand.close();
    await kernel.browsers.deleteByID(kernelBrowser.session_id);
    console.log("Browser session closed");
}

main().catch((err) => {
    console.error(err);
    process.exit(1);
});
```

### Browser Use

Browser Use handles downloads automatically when configured properly. Documentation for Browser Use downloads coming soon.

## Uploads

Playwright's `setInputFiles()` method allows you to upload files directly to file input elements. You can provide either a local file path or a buffer with file data.

<CodeGroup>
```typescript Typescript/Javascript
import Kernel from '@onkernel/sdk';
import { chromium } from 'playwright';
import fs from 'fs';

const kernel = new Kernel();

async function main() {
    // Create Kernel browser session
    const kernelBrowser = await kernel.browsers.create();
    console.log('Live view:', kernelBrowser.browser_live_view_url);

    // Connect Playwright
    const browser = await chromium.connectOverCDP(kernelBrowser.cdp_ws_url);
    const context = browser.contexts()[0] || (await browser.newContext());
    const page = context.pages()[0] || (await context.newPage());

    // Navigate to upload test page
    console.log('Navigating to upload test page');
    await page.goto('https://browser-tests-alpha.vercel.app/api/upload-test');

    // Option 1: Upload from a local file path
    // await page.locator('#fileUpload').setInputFiles('./path/to/local/file.png');

    // Option 2: Upload from a buffer (useful for dynamically generated content)
    const fileBuffer = fs.readFileSync('./test-file.txt');
    await page.locator('#fileUpload').setInputFiles({
        name: 'test-file.txt',
        mimeType: 'text/plain',
        buffer: fileBuffer,
    });
    console.log('File selected');

    // Submit the form and verify the upload
    await page.getByRole('button', { name: 'Upload' }).click();
    await page.waitForSelector('#uploadResult');
    const result = await page.locator('#uploadResult').textContent();
    console.log('Upload result:', result);

    await kernel.browsers.deleteByID(kernelBrowser.session_id);
    console.log('Browser deleted');
}

main();
````

```python Python
import asyncio
from pathlib import Path
from kernel import Kernel
from playwright.async_api import async_playwright

kernel = Kernel()


async def main():
    # Create Kernel browser session
    kernel_browser = kernel.browsers.create()
    print(f'Live view: {kernel_browser.browser_live_view_url}')

    async with async_playwright() as playwright:
        # Connect Playwright
        browser = await playwright.chromium.connect_over_cdp(kernel_browser.cdp_ws_url)
        context = browser.contexts[0] if browser.contexts else await browser.new_context()
        page = context.pages[0] if context.pages else await context.new_page()

        # Navigate to upload test page
        print('Navigating to upload test page')
        await page.goto('https://browser-tests-alpha.vercel.app/api/upload-test')

        # Option 1: Upload from a local file path
        # await page.locator('#fileUpload').set_input_files('./path/to/local/file.png')

        # Option 2: Upload from a buffer (useful for dynamically generated content)
        file_buffer = Path('./test-file.txt').read_bytes()
        await page.locator('#fileUpload').set_input_files({
            'name': 'test-file.txt',
            'mimeType': 'text/plain',
            'buffer': file_buffer,
        })
        print('File selected')

        # Submit the form and verify the upload
        await page.get_by_role('button', name='Upload').click()
        await page.wait_for_selector('#uploadResult')
        result = await page.locator('#uploadResult').text_content()
        print(f'Upload result: {result}')

        await browser.close()

    kernel.browsers.delete_by_id(kernel_browser.session_id)
    print('Browser deleted')


if __name__ == '__main__':
    asyncio.run(main())
````

</CodeGroup>
