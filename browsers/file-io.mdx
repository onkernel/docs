---
title: "File I/O"
description: "Downloads, uploads, and manipulating the browser's filesystem"
---

Kernel browsers run in fully sandboxed environments with a writable filesystem that you control. Anything your automation downloads during a session is saved inside this filesystem and can be retrieved directly while the session is running.

## Downloads

Playwright performs downloads via the browser itself, so there are a few steps:

- Create a browser session
- Configure where the browser saves downloads
- Perform the download
- Retrieve the file from the browser's filesystem

<Info>
The CDP `downloadProgress` event signals when the browser finishes writing a file, but there may be a brief delay before the file becomes available through Kernel's File I/O APIs. This is especially true for larger downloads. We recommend polling `listFiles` to confirm the file exists before attempting to read it.
</Info>

<CodeGroup>
```typescript Typescript/Javascript
import Kernel from '@onkernel/sdk';
import { chromium } from 'playwright';
import fs from 'fs';
import pTimeout from 'p-timeout';

const DOWNLOAD_DIR = '/tmp/downloads';
const kernel = new Kernel();

// Poll listFiles until the expected file appears in the directory
async function waitForFile(
  sessionId: string,
  dir: string,
  filename: string,
  timeoutMs = 30_000
) {
  const start = Date.now();
  while (Date.now() - start < timeoutMs) {
    const files = await kernel.browsers.fs.listFiles(sessionId, { path: dir });
    if (files.some((f) => f.name === filename)) {
      return;
    }
    await new Promise((r) => setTimeout(r, 500));
  }
  throw new Error(`File ${filename} not found after ${timeoutMs}ms`);
}

async function main() {
  const kernelBrowser = await kernel.browsers.create();
  console.log('live view:', kernelBrowser.browser_live_view_url);

  const browser = await chromium.connectOverCDP(kernelBrowser.cdp_ws_url);
  const context = browser.contexts()[0] || (await browser.newContext());
  const page = context.pages()[0] || (await context.newPage());

  const client = await context.newCDPSession(page);
  await client.send('Browser.setDownloadBehavior', {
    behavior: 'allow',
    downloadPath: DOWNLOAD_DIR,
    eventsEnabled: true,
  });

  // Set up CDP listeners to capture download filename and completion
  let downloadFilename: string | undefined;
  let downloadState: string | undefined;
  let downloadCompletedResolve!: () => void;
  const downloadCompleted = new Promise<void>((resolve) => {
    downloadCompletedResolve = resolve;
  });

  client.on('Browser.downloadWillBegin', (event) => {
    downloadFilename = event.suggestedFilename ?? 'unknown';
    console.log('Download started:', downloadFilename);
  });

  client.on('Browser.downloadProgress', (event) => {
    if (event.state === 'completed' || event.state === 'canceled') {
      downloadState = event.state;
      downloadCompletedResolve();
    }
  });

  console.log('Navigating to download test page');
  await page.goto('https://browser-tests-alpha.vercel.app/api/download-test');
  await page.getByRole('link', { name: 'Download File' }).click();

  try {
    await pTimeout(downloadCompleted, {
      milliseconds: 10_000,
      message: new Error('Download timed out after 10 seconds'),
    });
    console.log('Download completed');
  } catch (err) {
    console.error(err);
    throw err;
  }

  if (!downloadFilename) {
    throw new Error('Unable to determine download filename');
  }

  if (downloadState === 'canceled') {
    throw new Error('Download was canceled');
  }

  // Wait for the file to be available via Kernel's File I/O APIs
  console.log(`Waiting for file: ${downloadFilename}`);
  await waitForFile(kernelBrowser.session_id, DOWNLOAD_DIR, downloadFilename);

  const remotePath = `${DOWNLOAD_DIR}/${downloadFilename}`;
  console.log(`Reading file: ${remotePath}`);

  const resp = await kernel.browsers.fs.readFile(kernelBrowser.session_id, {
    path: remotePath,
  });

  const bytes = await resp.bytes();
  fs.mkdirSync('downloads', { recursive: true });
  const localPath = `downloads/${downloadFilename}`;
  fs.writeFileSync(localPath, bytes);
  console.log(`Saved to ${localPath}`);

  await kernel.browsers.deleteByID(kernelBrowser.session_id);
  console.log('Kernel browser deleted successfully.');
}

main();
```

```python Python
import asyncio
import os
import time
from kernel import Kernel
from playwright.async_api import async_playwright

DOWNLOAD_DIR = "/tmp/downloads"
kernel = Kernel()


# Poll list_files until the expected file appears in the directory
async def wait_for_file(
    session_id: str, dir: str, filename: str, timeout_sec: float = 30
):
    start = time.time()
    while time.time() - start < timeout_sec:
        files = kernel.browsers.fs.list_files(session_id, path=dir)
        if any(f.name == filename for f in files):
            return
        await asyncio.sleep(0.5)
    raise TimeoutError(f"File {filename} not found after {timeout_sec}s")


async def main():
    kernel_browser = kernel.browsers.create()
    print("Kernel browser live view url:", kernel_browser.browser_live_view_url)

    async with async_playwright() as playwright:
        browser = await playwright.chromium.connect_over_cdp(kernel_browser.cdp_ws_url)
        context = browser.contexts[0]
        page = context.pages[0] if len(context.pages) > 0 else await context.new_page()

        cdp_session = await context.new_cdp_session(page)
        await cdp_session.send(
            "Browser.setDownloadBehavior",
            {
                "behavior": "allow",
                "downloadPath": DOWNLOAD_DIR,
                "eventsEnabled": True,
            },
        )

        download_completed = asyncio.Event()
        download_filename: str | None = None
        download_state: str | None = None

        def _on_download_begin(event):
            nonlocal download_filename
            download_filename = event.get("suggestedFilename", "unknown")
            print(f"Download started: {download_filename}")

        def _on_download_progress(event):
            nonlocal download_state
            if event.get("state") in ["completed", "canceled"]:
                download_state = event.get("state")
                download_completed.set()

        cdp_session.on("Browser.downloadWillBegin", _on_download_begin)
        cdp_session.on("Browser.downloadProgress", _on_download_progress)

        print("Navigating to download test page")
        await page.goto("https://browser-tests-alpha.vercel.app/api/download-test")
        await page.get_by_role("link", name="Download File").click()

        try:
            await asyncio.wait_for(download_completed.wait(), timeout=10)
            print("Download completed")
        except asyncio.TimeoutError:
            print("Download timed out after 10 seconds")
            raise

        if download_state == "canceled":
            raise RuntimeError("Download was canceled")

        # Wait for the file to be available via Kernel's File I/O APIs
        print(f"Waiting for file: {download_filename}")
        await wait_for_file(kernel_browser.session_id, DOWNLOAD_DIR, download_filename)

        resp = kernel.browsers.fs.read_file(
            kernel_browser.session_id, path=f"{DOWNLOAD_DIR}/{download_filename}"
        )
        local_path = f"./downloads/{download_filename}"
        os.makedirs("./downloads", exist_ok=True)
        resp.write_to_file(local_path)
        print(f"Saved to {local_path}")

        kernel.browsers.delete_by_id(kernel_browser.session_id)
        print("Kernel browser deleted successfully.")


if __name__ == "__main__":
    asyncio.run(main())
```

```typescript Stagehand v3
import "dotenv/config";
import { Stagehand } from "@browserbasehq/stagehand";
import Kernel from "@onkernel/sdk";
import fs from "fs";

// Poll listFiles until the expected file appears in the directory
async function waitForFile(
  kernel: Kernel,
  sessionId: string,
  dir: string,
  filename: string,
  timeoutMs = 30_000
) {
  const start = Date.now();
  while (Date.now() - start < timeoutMs) {
    const files = await kernel.browsers.fs.listFiles(sessionId, { path: dir });
    if (files.some((f) => f.name === filename)) {
      return;
    }
    await new Promise((r) => setTimeout(r, 500));
  }
  throw new Error(`File ${filename} not found after ${timeoutMs}ms`);
}

async function main() {
  // Initialize Kernel client
  const kernel = new Kernel({
    apiKey: process.env.KERNEL_API_KEY,
  });

  // Create browser using Kernel MCP
  console.log("Creating browser via Kernel...");
  const kernelBrowser = await kernel.browsers.create({
    stealth: true,
  });

  console.log(`Kernel Browser Session Started`);
  console.log(`Session ID: ${kernelBrowser.session_id}`);
  console.log(`Watch live: ${kernelBrowser.browser_live_view_url}`);
  const DOWNLOAD_DIR = "/tmp/downloads";

  // Initialize Stagehand with Kernel's CDP URL
  const stagehand = new Stagehand({
    env: "LOCAL",
    verbose: 1,
    localBrowserLaunchOptions: {
      cdpUrl: kernelBrowser.cdp_ws_url,
      downloadsPath: DOWNLOAD_DIR,
      acceptDownloads: true,
    },
  });

  await stagehand.init();

  const page = stagehand.context.pages()[0];

  await page.goto("https://browser-tests-alpha.vercel.app/api/download-test");

  // Use Stagehand to click the download button
  await stagehand.act("Click the download file link");
  console.log("Download triggered");

  // Wait a bit for the download to complete
  await new Promise((r) => setTimeout(r, 6000));

  // List files in the download directory to see what was downloaded
  console.log("Checking download directory...");
  const files = await kernel.browsers.fs.listFiles(kernelBrowser.session_id, {
    path: DOWNLOAD_DIR,
  });

  if (files.length === 0) {
    console.log("No files found in download directory");
  } else {
    const downloadedFile = files[0];
    console.log(`File found: ${downloadedFile.name}`);

    // Wait for the file to be fully available via Kernel's File I/O APIs
    console.log(`Waiting for file: ${downloadedFile.name}`);
    await waitForFile(
      kernel,
      kernelBrowser.session_id,
      DOWNLOAD_DIR,
      downloadedFile.name
    );

    const remotePath = `${DOWNLOAD_DIR}/${downloadedFile.name}`;
    console.log(`Reading file from: ${remotePath}`);

    // Read the file from Kernel browser's filesystem
    const resp = await kernel.browsers.fs.readFile(kernelBrowser.session_id, {
      path: remotePath,
    });

    // Save to local filesystem
    const bytes = await resp.bytes();
    fs.mkdirSync("downloads", { recursive: true });
    const localPath = `downloads/${downloadedFile.name}`;
    fs.writeFileSync(localPath, bytes);
  }

  // Clean up
  await stagehand.close();
  // await kernel.browsers.deleteByID(kernelBrowser.session_id);
  console.log("Browser session closed");
}

main().catch((err) => {
  console.error(err);
  process.exit(1);
});
```
</CodeGroup>

We recommend using the [list files](/api-reference/browsers/list-files-in-a-directory) API to poll for file availability before calling [read file](/api-reference/browsers/read-file-contents), as shown in the examples above. This approach ensures reliable downloads, especially for larger files. You can also use `listFiles` to enumerate and save all downloads at the end of a session.

## Uploads

You can upload from your local filesystem into the browser directly using Playwright's file input helpers.

<CodeGroup>
```typescript Typescript/Javascript
const localPath = '/path/to/a/file.txt';

console.log(`Uploading ${localPath}...`);
await page.locator('#fileUpload').setInputFiles(localPath);
console.log('Upload completed');
```

```python Python
local_path = "/path/to/a/file.txt"

print(f"Uploading {local_path}...")
await page.locator("#fileUpload").set_input_files(str(local_path))
print("Upload completed")
```
</CodeGroup>
